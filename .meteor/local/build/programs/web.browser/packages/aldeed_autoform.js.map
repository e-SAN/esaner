)]}'
{"version":3,"file":"/packages/aldeed:autoform.js","sources":["aldeed:autoform/autoform-common.js","aldeed:autoform/templates/bootstrap3/bootstrap3.html","aldeed:autoform/templates/bootstrap3/bootstrap3.js","aldeed:autoform/templates/bootstrap3-span/bootstrap3-span.html","aldeed:autoform/templates/bootstrap3-span/bootstrap3-span.js","aldeed:autoform/templates/bootstrap3-horizontal/bootstrap3-horizontal.html","aldeed:autoform/templates/bootstrap3-horizontal/bootstrap3-horizontal.js","aldeed:autoform/templates/plain/plain.html","aldeed:autoform/templates/plain/plain.js","aldeed:autoform/templates/plain-fieldset/plain-fieldset.html","aldeed:autoform/templates/plain-fieldset/plain-fieldset.js","aldeed:autoform/templates/plain-span/plain-span.html","aldeed:autoform/templates/plain-span/plain-span.js","aldeed:autoform/utility.js","aldeed:autoform/form-preserve.js","aldeed:autoform/autoform-hooks.js","aldeed:autoform/autoform-inputs.js","aldeed:autoform/autoform-formdata.js","aldeed:autoform/autoform-arrays.js","aldeed:autoform/autoform.js","aldeed:autoform/components/autoForm/autoForm.html","aldeed:autoform/components/autoForm/autoForm.js","aldeed:autoform/components/quickForm/quickForm.html","aldeed:autoform/components/quickForm/quickForm.js","aldeed:autoform/components/afArrayField/afArrayField.html","aldeed:autoform/components/afArrayField/afArrayField.js","aldeed:autoform/components/afEachArrayItem/afEachArrayItem.html","aldeed:autoform/components/afEachArrayItem/afEachArrayItem.js","aldeed:autoform/components/afFieldInput/afFieldInput.html","aldeed:autoform/components/afFieldInput/afFieldInput.js","aldeed:autoform/components/afFieldLabel/afFieldLabel.html","aldeed:autoform/components/afFieldSelect/afFieldSelect.html","aldeed:autoform/components/afFieldSelect/afFieldSelect.js","aldeed:autoform/components/afFormGroup/afFormGroup.html","aldeed:autoform/components/afFormGroup/afFormGroup.js","aldeed:autoform/components/afObjectField/afObjectField.html","aldeed:autoform/components/afQuickField/afQuickField.html","aldeed:autoform/components/afQuickField/afQuickField.js","aldeed:autoform/components/afQuickFields/afQuickFields.html","aldeed:autoform/components/afQuickFields/afQuickFields.js","aldeed:autoform/autoform-helpers.js","aldeed:autoform/autoform-validation.js","aldeed:autoform/autoform-events.js","aldeed:autoform/autoform-api.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,uD;;AAEA,oD;AACA,4B;AACA,kC;AACA,G;;;;;;;;;;;;;;;;;;;ACJA,6C;AACA,8F;AACA,kB;AACA,yC;AACA,gF;AACA,iB;AACA,0E;AACA,yD;AACA,gB;AACA,qF;AACA,4F;AACA,U;AACA,qB;AACA,uE;AACA,yC;AACA,mE;AACA,qB;AACA,mF;AACA,yE;AACA,mD;AACA,2F;AACA,uB;AACA,sD;AACA,wD;AACA,2B;AACA,uB;AACA,0C;AACA,+C;AACA,mB;AACA,O;AACA,K;AACA,I;;AAEA,gD;AACA,oG;AACA,kB;AACA,2C;AACA,uD;AACA,6B;AACA,6E;AACA,2D;AACA,Q;AACA,M;AACA,I;;AAEA,8C;AACA,gG;AACA,kB;AACA,mB;AACA,uB;AACA,6D;AACA,qB;AACA,uB;AACA,0E;AACA,K;AACA,iB;AACA,uD;AACA,0C;AACA,6E;AACA,mD;AACA,Q;AACA,yB;AACA,I;;AAEA,mD;AACA,0G;AACA,kB;AACA,gC;AACA,oE;AACA,iB;AACA,iC;AACA,yB;AACA,mE;AACA,uB;AACA,yB;AACA,4E;AACA,O;AACA,mB;AACA,yD;AACA,8C;AACA,0E;AACA,yC;AACA,K;AACA,I;;AAEA,2C;AACA,0F;AACA,kB;AACA,mB;AACA,oB;AACA,6D;AACA,kB;AACA,uB;AACA,0E;AACA,K;AACA,iB;AACA,uD;AACA,0C;AACA,6E;AACA,mD;AACA,Q;AACA,yB;AACA,I;;AAEA,gD;AACA,oG;AACA,kB;AACA,gC;AACA,oE;AACA,iB;AACA,iC;AACA,sB;AACA,mE;AACA,oB;AACA,yB;AACA,4E;AACA,O;AACA,mB;AACA,yD;AACA,8C;AACA,0E;AACA,yC;AACA,K;AACA,I;;AAEA,qD;AACA,8G;AACA,kB;AACA,2E;AACA,I;;AAEA,iD;AACA,sG;AACA,kB;AACA,4C;AACA,uD;AACA,2C;AACA,kF;AACA,iB;AACA,qD;AACA,8E;AACA,mB;AACA,c;AACA,I;;AAEA,4C;AACA,4F;AACA,kB;AACA,4C;AACA,uD;AACA,uC;AACA,oE;AACA,iB;AACA,4D;AACA,+D;AACA,+B;AACA,0E;AACA,oB;AACA,c;AACA,I;;AAEA,8C;AACA,gG;AACA,kB;AACA,8C;AACA,uD;AACA,M;AACA,uB;AACA,0E;AACA,K;AACA,M;AACA,I;;AAEA,2C;AACA,0F;AACA,kB;AACA,gC;AACA,sB;AACA,yE;AACA,M;AACA,uB;AACA,0E;AACA,K;AACA,iB;AACA,uD;AACA,M;AACA,I;;AAEA,+C;AACA,kG;AACA,kB;AACA,mB;AACA,yB;AACA,mD;AACA,qF;AACA,+D;AACA,Y;AACA,qB;AACA,2B;AACA,W;AACA,K;AACA,wC;AACA,oD;AACA,iB;AACA,uD;AACA,iF;AACA,mB;AACA,oE;AACA,mB;AACA,gD;AACA,+E;AACA,iB;AACA,kE;AACA,2B;AACA,yB;AACA,4B;AACA,6F;AACA,2D;AACA,S;AACA,e;AACA,I;;AAEA,iD;AACA,sG;AACA,kB;AACA,mB;AACA,kC;AACA,yB;AACA,4B;AACA,0B;AACA,0B;AACA,4B;AACA,6E;AACA,2D;AACA,Q;AACA,sC;AACA,yB;AACA,sC;AACA,iF;AACA,2D;AACA,Q;AACA,iB;AACA,oC;AACA,2B;AACA,8B;AACA,+F;AACA,6D;AACA,W;AACA,sB;AACA,kD;AACA,Y;AACA,4E;AACA,gF;AACA,uF;AACA,M;AACA,iB;AACA,mE;AACA,yB;AACA,I;;AAEA,gD;AACA,oG;AACA,kB;AACA,mB;AACA,kC;AACA,yB;AACA,4B;AACA,4B;AACA,6E;AACA,2D;AACA,Q;AACA,sC;AACA,iF;AACA,2D;AACA,Q;AACA,iB;AACA,iC;AACA,qC;AACA,8B;AACA,2B;AACA,8B;AACA,+F;AACA,6D;AACA,W;AACA,+B;AACA,yB;AACA,yB;AACA,iD;AACA,Y;AACA,4E;AACA,oF;AACA,mF;AACA,M;AACA,iB;AACA,iF;AACA,oC;AACA,sD;AACA,iC;AACA,wB;AACA,8C;AACA,mG;AACA,iE;AACA,yE;AACA,wE;AACA,Y;AACA,qB;AACA,8C;AACA,mE;AACA,sB;AACA,8C;AACA,8B;AACA,oC;AACA,6B;AACA,2D;AACA,gB;AACA,wE;AACA,uC;AACA,0C;AACA,qF;AACA,4F;AACA,U;AACA,qB;AACA,sE;AACA,oE;AACA,O;AACA,uC;AACA,+F;AACA,4D;AACA,oE;AACA,mE;AACA,Q;AACA,iB;AACA,kC;AACA,gC;AACA,kC;AACA,mD;AACA,yC;AACA,mF;AACA,Q;AACA,4C;AACA,uF;AACA,Q;AACA,4C;AACA,uF;AACA,O;AACA,kB;AACA,yC;AACA,mC;AACA,yB;AACA,I;;;;;;;;;;;;;;;;;;;AC9VA,E;AACA,6C;AACA,G;;AAEA,6C;AACA,qC;AACA,iC;AACA,iE;AACA,uC;AACA,iD;AACA,qG;AACA,Y;AACA,2C;AACA,K;AACA,qC;AACA,wD;AACA,qB;AACA,G;AACA,G;;AAEA,0C;AACA,4D;AACA,2B;AACA,gC;AACA,mD;AACA,2C;AACA,Y;AACA,wC;AACA,K;AACA,gB;AACA,G;AACA,G;;AAEA,4C;AACA,8C;AACA,oB;;AAEA,4D;AACA,2D;AACA,G;AACA,G;;AAEA,+B;AACA,gC;AACA,0C;AACA,qC;AACA,U;AACA,mC;AACA,G;AACA,c;AACA,C;;AAEA,8C;AACA,0B;AACA,G;;AAEA,yC;AACA,0B;AACA,G;;AAEA,2C;AACA,0B;AACA,G;;AAEA,wC;AACA,0B;AACA,G;;AAEA,+B;AACA,gC;AACA,sB;AACA,sB;AACA,G;AACA,c;AACA,C;;AAEA,2C;AACA,0B;AACA,G;;AAEA,wC;AACA,0B;AACA,G;;AAEA,gD;AACA,0B;AACA,G;;AAEA,6C;AACA,0B;AACA,G;;AAEA,yC;AACA,6C;AACA,oB;AACA,gB;AACA,uB;AACA,M;AACA,wB;AACA,yB;AACA,K;AACA,gB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACtGA,qD;AACA,8G;AACA,kB;AACA,0C;AACA,uD;AACA,6B;AACA,6E;AACA,2D;AACA,Q;AACA,M;AACA,I;;;;;;;;;;;;;;;;;;;ACXA,E;AACA,kD;AACA,G;;AAEA,kD;AACA,wC;AACA,0C;AACA,gE;AACA,kE;AACA,gD;AACA,oG;AACA,Y;AACA,0C;AACA,K;AACA,oB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACfA,wD;AACA,oH;AACA,kB;AACA,yC;AACA,4D;AACA,iB;AACA,0E;AACA,yD;AACA,gB;AACA,qF;AACA,6F;AACA,4D;AACA,uE;AACA,kE;AACA,U;AACA,qB;AACA,uE;AACA,yC;AACA,mE;AACA,qB;AACA,qC;AACA,+B;AACA,iC;AACA,+B;AACA,iE;AACA,W;AACA,kC;AACA,+B;AACA,iE;AACA,W;AACA,4D;AACA,yE;AACA,qD;AACA,2F;AACA,uB;AACA,wD;AACA,wD;AACA,6B;AACA,uB;AACA,8C;AACA,8D;AACA,mB;AACA,O;AACA,K;AACA,I;;AAEA,0D;AACA,wH;AACA,kB;AACA,mB;AACA,yB;AACA,mD;AACA,qF;AACA,+D;AACA,Y;AACA,qB;AACA,2B;AACA,W;AACA,K;AACA,oC;AACA,oD;AACA,iB;AACA,+D;AACA,0E;AACA,oB;AACA,iB;AACA,uD;AACA,6D;AACA,mB;AACA,oE;AACA,mB;AACA,0B;AACA,yB;AACA,iE;AACA,K;AACA,iD;AACA,2D;AACA,iB;AACA,kE;AACA,6B;AACA,yB;AACA,4B;AACA,6F;AACA,2D;AACA,S;AACA,0B;AACA,I;;AAEA,4D;AACA,4H;AACA,kB;AACA,mB;AACA,yB;AACA,mD;AACA,qF;AACA,+D;AACA,Y;AACA,qB;AACA,2B;AACA,W;AACA,K;AACA,+C;AACA,2D;AACA,iB;AACA,kE;AACA,0B;AACA,yB;AACA,iE;AACA,K;AACA,2B;AACA,uD;AACA,6B;AACA,yB;AACA,mD;AACA,Y;AACA,4E;AACA,gF;AACA,wF;AACA,4C;AACA,M;AACA,iB;AACA,mE;AACA,qD;AACA,I;;AAEA,2D;AACA,0H;AACA,kB;AACA,mB;AACA,yB;AACA,mD;AACA,qF;AACA,+D;AACA,Y;AACA,qB;AACA,2B;AACA,W;AACA,K;AACA,+C;AACA,2D;AACA,iB;AACA,kE;AACA,0B;AACA,yB;AACA,iE;AACA,K;AACA,2B;AACA,uD;AACA,wC;AACA,iF;AACA,2D;AACA,Q;AACA,iB;AACA,qC;AACA,qC;AACA,kC;AACA,2B;AACA,8B;AACA,+F;AACA,6D;AACA,W;AACA,uC;AACA,6B;AACA,yB;AACA,qD;AACA,Y;AACA,4E;AACA,oF;AACA,mF;AACA,M;AACA,iB;AACA,iF;AACA,wC;AACA,sD;AACA,qC;AACA,wB;AACA,kD;AACA,mG;AACA,iE;AACA,yE;AACA,wE;AACA,Y;AACA,qB;AACA,kD;AACA,mE;AACA,sB;AACA,8C;AACA,kC;AACA,wC;AACA,6B;AACA,+D;AACA,gB;AACA,wE;AACA,sC;AACA,U;AACA,qB;AACA,sE;AACA,oF;AACA,O;AACA,2C;AACA,+F;AACA,4D;AACA,oE;AACA,mE;AACA,Q;AACA,iB;AACA,sC;AACA,gC;AACA,sC;AACA,mD;AACA,yC;AACA,mF;AACA,Q;AACA,4C;AACA,uF;AACA,Q;AACA,4C;AACA,uF;AACA,O;AACA,kB;AACA,yC;AACA,2C;AACA,qD;AACA,I;;AAEA,yD;AACA,sH;AACA,kB;AACA,8B;AACA,uD;AACA,iB;AACA,mC;AACA,yB;AACA,wC;AACA,uB;AACA,yB;AACA,4E;AACA,O;AACA,mB;AACA,yE;AACA,2B;AACA,iB;AACA,+B;AACA,yB;AACA,+D;AACA,uB;AACA,yB;AACA,4E;AACA,O;AACA,mB;AACA,yD;AACA,4C;AACA,+E;AACA,qD;AACA,U;AACA,qC;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;AClQA,qB;AACA,e;AACA,M;AACA,4B;AACA,yB;AACA,qB;AACA,C;;AAEA,qD;AACA,2C;AACA,0B;AACA,e;AACA,qC;AACA,K;AACA,I;AACA,2C;AACA,0B;AACA,e;AACA,iC;AACA,K;AACA,I;AACA,4D;AACA,2B;AACA,gC;AACA,mD;AACA,2C;AACA,Y;AACA,wC;AACA,K;AACA,gB;AACA,I;AACA,kC;AACA,oD;AACA,2C;AACA,yC;AACA,Y;AACA,uC;AACA,K;AACA,+B;AACA,oC;AACA,2B;AACA,gC;AACA,e;AACA,G;AACA,G;;AAEA,uD;AACA,iC;AACA,oD;AACA,oC;AACA,qC;AACA,K;AACA,mE;AACA,qE;AACA,8E;AACA,8C;AACA,Y;AACA,mC;AACA,K;AACA,gB;AACA,I;AACA,iC;AACA,oD;AACA,iC;AACA,gB;AACA,I;AACA,sC;AACA,oD;AACA,iE;AACA,uC;AACA,iD;AACA,qG;AACA,Y;AACA,2C;AACA,K;AACA,qB;AACA,I;AACA,iC;AACA,2C;AACA,yC;AACA,I;AACA,+C;AACA,oB;;AAEA,4D;AACA,iG;AACA,G;AACA,G;;AAEA,yD;AACA,iC;AACA,+B;AACA,yC;AACA,I;AACA,iC;AACA,yB;AACA,Y;AACA,6B;AACA,mC;AACA,uB;AACA,K;AACA,G;AACA,G;;AAEA,wD;AACA,iC;AACA,+B;AACA,yC;AACA,I;AACA,iC;AACA,+B;AACA,Y;AACA,6B;AACA,mC;AACA,uB;AACA,M;AACA,G;AACA,G;;AAEA,sD;AACA,qB;AACA,kC;AACA,wB;AACA,wB;AACA,K;AACA,gB;AACA,I;AACA,qC;AACA,kC;AACA,wB;AACA,wB;AACA,K;AACA,wB;AACA,uD;AACA,Y;AACA,oD;AACA,K;AACA,gB;AACA,I;AACA,6B;AACA,+B;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC7IA,wC;AACA,oF;AACA,kB;AACA,yC;AACA,gF;AACA,iB;AACA,0E;AACA,yD;AACA,gB;AACA,qF;AACA,4F;AACA,U;AACA,qB;AACA,uE;AACA,yC;AACA,mE;AACA,qB;AACA,mF;AACA,yE;AACA,mD;AACA,2F;AACA,uB;AACA,sD;AACA,wD;AACA,2B;AACA,uB;AACA,0C;AACA,+C;AACA,mB;AACA,O;AACA,K;AACA,I;;AAEA,2C;AACA,0F;AACA,kB;AACA,2C;AACA,uD;AACA,6B;AACA,6E;AACA,2D;AACA,Q;AACA,M;AACA,I;;AAEA,yC;AACA,sF;AACA,kB;AACA,yC;AACA,qB;AACA,uB;AACA,0E;AACA,K;AACA,iB;AACA,uD;AACA,wB;AACA,uB;AACA,yE;AACA,K;AACA,4B;AACA,6E;AACA,mD;AACA,Q;AACA,O;AACA,I;;AAEA,8C;AACA,gG;AACA,kB;AACA,gC;AACA,oE;AACA,iB;AACA,uD;AACA,uB;AACA,yB;AACA,4E;AACA,O;AACA,mB;AACA,yD;AACA,0B;AACA,yB;AACA,2E;AACA,O;AACA,8B;AACA,0E;AACA,mB;AACA,K;AACA,I;;AAEA,sC;AACA,gF;AACA,kB;AACA,yC;AACA,qB;AACA,uB;AACA,0E;AACA,K;AACA,iB;AACA,uD;AACA,wB;AACA,uB;AACA,yE;AACA,K;AACA,4B;AACA,6E;AACA,mD;AACA,Q;AACA,O;AACA,I;;AAEA,2C;AACA,0F;AACA,kB;AACA,gC;AACA,oE;AACA,iB;AACA,uD;AACA,uB;AACA,yB;AACA,4E;AACA,O;AACA,mB;AACA,yD;AACA,0B;AACA,yB;AACA,2E;AACA,O;AACA,8B;AACA,0E;AACA,mB;AACA,K;AACA,I;;AAEA,gD;AACA,oG;AACA,kB;AACA,8B;AACA,2B;AACA,iB;AACA,2E;AACA,6B;AACA,2F;AACA,M;AACA,I;;AAEA,4C;AACA,4F;AACA,kB;AACA,4C;AACA,2E;AACA,2C;AACA,kF;AACA,iB;AACA,qD;AACA,8E;AACA,mB;AACA,c;AACA,I;;AAEA,uC;AACA,kF;AACA,kB;AACA,4C;AACA,2E;AACA,uC;AACA,oE;AACA,iB;AACA,0D;AACA,+D;AACA,+B;AACA,0E;AACA,oB;AACA,c;AACA,I;;AAEA,yC;AACA,sF;AACA,kB;AACA,8C;AACA,2E;AACA,M;AACA,uB;AACA,0E;AACA,K;AACA,M;AACA,I;;AAEA,sC;AACA,gF;AACA,kB;AACA,gC;AACA,sB;AACA,yE;AACA,M;AACA,uB;AACA,0E;AACA,K;AACA,iB;AACA,2E;AACA,M;AACA,I;;AAEA,0C;AACA,wF;AACA,kB;AACA,mB;AACA,yB;AACA,kC;AACA,qF;AACA,+D;AACA,Y;AACA,qB;AACA,2B;AACA,S;AACA,K;AACA,wC;AACA,wE;AACA,iB;AACA,uD;AACA,iF;AACA,mB;AACA,oE;AACA,mB;AACA,gD;AACA,+E;AACA,iB;AACA,kE;AACA,iD;AACA,6F;AACA,2D;AACA,S;AACA,e;AACA,I;;AAEA,4C;AACA,4F;AACA,kB;AACA,oE;AACA,6E;AACA,2D;AACA,Q;AACA,iD;AACA,Y;AACA,4E;AACA,gF;AACA,uF;AACA,M;AACA,iB;AACA,mE;AACA,c;AACA,I;;AAEA,2C;AACA,0F;AACA,kB;AACA,oE;AACA,6E;AACA,2D;AACA,Q;AACA,sC;AACA,iF;AACA,2D;AACA,Q;AACA,iB;AACA,iC;AACA,2C;AACA,0C;AACA,+F;AACA,6D;AACA,W;AACA,8B;AACA,gD;AACA,Y;AACA,4E;AACA,oF;AACA,mF;AACA,M;AACA,iB;AACA,iF;AACA,mC;AACA,sC;AACA,qD;AACA,gB;AACA,wE;AACA,sC;AACA,U;AACA,qB;AACA,sE;AACA,2C;AACA,mG;AACA,iE;AACA,yE;AACA,wE;AACA,Y;AACA,qB;AACA,0C;AACA,yC;AACA,mC;AACA,gC;AACA,O;AACA,qC;AACA,+F;AACA,4D;AACA,oE;AACA,mE;AACA,Q;AACA,iB;AACA,iC;AACA,gC;AACA,gC;AACA,mC;AACA,yC;AACA,mF;AACA,Q;AACA,4C;AACA,uF;AACA,Q;AACA,4C;AACA,uF;AACA,O;AACA,qC;AACA,c;AACA,I;;;;;;;;;;;;;;;;;;;ACnUA,E;AACA,wC;AACA,G;;AAEA,wC;AACA,qC;AACA,0C;AACA,iE;AACA,qC;AACA,wD;AACA,qB;AACA,G;AACA,G;;AAEA,qC;AACA,4D;AACA,2B;AACA,gC;AACA,mD;AACA,2C;AACA,K;AACA,gB;AACA,G;AACA,G;;AAEA,+B;AACA,gC;AACA,sB;AACA,sB;AACA,G;AACA,c;AACA,C;;AAEA,sC;AACA,0B;AACA,G;;AAEA,mC;AACA,0B;AACA,G;;AAEA,2C;AACA,0B;AACA,G;;AAEA,wC;AACA,0B;AACA,G;;AAEA,oC;AACA,6C;AACA,mB;AACA,gB;AACA,uB;AACA,M;AACA,wB;AACA,yB;AACA,K;AACA,gB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;AC3DA,iD;AACA,sG;AACA,kB;AACA,yC;AACA,gF;AACA,iB;AACA,0E;AACA,8E;AACA,kF;AACA,qB;AACA,gE;AACA,sD;AACA,0B;AACA,sD;AACA,gB;AACA,qF;AACA,4F;AACA,U;AACA,qB;AACA,uE;AACA,oD;AACA,mE;AACA,qB;AACA,mF;AACA,yE;AACA,qD;AACA,2F;AACA,uB;AACA,wD;AACA,wD;AACA,6B;AACA,uB;AACA,8C;AACA,+C;AACA,mB;AACA,O;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACtCA,8C;AACA,8D;AACA,2B;AACA,gC;AACA,mD;AACA,2C;AACA,K;AACA,gB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;;ACRA,gD;AACA,oG;AACA,kB;AACA,0C;AACA,uD;AACA,6B;AACA,6E;AACA,2D;AACA,Q;AACA,M;AACA,I;;;;;;;;;;;;;;;;;;;ACXA,E;AACA,6C;AACA,G;;AAEA,6C;AACA,qC;AACA,iC;AACA,wD;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACTA,W;AACA,K;AACA,+B;AACA,a;AACA,wC;AACA,sB;AACA,I;AACA,6E;AACA,kD;AACA,K;AACA,mE;AACA,mC;AACA,oC;AACA,kD;AACA,oF;AACA,8B;AACA,4B;AACA,S;AACA,kC;AACA,sF;AACA,8B;AACA,4B;AACA,S;AACA,8D;AACA,0B;AACA,mF;AACA,0B;AACA,O;AACA,O;AACA,kB;AACA,I;AACA,K;AACA,gC;AACA,a;AACA,kF;AACA,4E;AACA,+E;AACA,uB;AACA,K;AACA,gE;AACA,mB;AACA,gC;AACA,wC;AACA,iG;AACA,yB;AACA,wB;AACA,kC;AACA,wB;AACA,oF;AACA,wB;AACA,O;AACA,kJ;AACA,gG;AACA,wB;AACA,O;AACA,O;AACA,iB;AACA,I;AACA,K;AACA,kC;AACA,a;AACA,4E;AACA,0C;AACA,I;AACA,2E;AACA,yE;AACA,uD;AACA,K;AACA,gE;AACA,sB;;AAEA,kB;AACA,oC;AACA,yD;AACA,gB;AACA,0F;AACA,+D;AACA,mE;;AAEA,8B;AACA,8B;AACA,K;AACA,4B;AACA,8B;AACA,K;AACA,oB;AACA,I;AACA,K;AACA,oC;AACA,a;AACA,2E;AACA,wB;AACA,I;AACA,oF;AACA,K;AACA,qD;AACA,oB;AACA,iD;AACA,Y;;AAEA,uD;AACA,uB;;AAEA,yB;AACA,2C;AACA,O;AACA,K;AACA,kB;AACA,I;AACA,K;AACA,6B;AACA,a;AACA,wB;AACA,6B;AACA,I;AACA,0E;AACA,kC;AACA,K;AACA,oC;AACA,yE;AACA,mC;AACA,2B;AACA,sB;AACA,Y;AACA,iB;AACA,K;AACA,I;AACA,K;AACA,2B;AACA,a;AACA,qB;AACA,mB;AACA,I;AACA,sE;AACA,0D;AACA,K;AACA,gC;AACA,0B;AACA,kC;AACA,2B;AACA,oD;AACA,iB;AACA,6D;AACA,O;AACA,iB;AACA,K;AACA,e;AACA,I;AACA,K;AACA,4B;AACA,a;AACA,6B;AACA,yB;AACA,+C;AACA,I;AACA,8F;AACA,8F;AACA,+C;AACA,K;AACA,uC;AACA,mC;AACA,4D;AACA,K;;AAEA,+B;AACA,c;AACA,qD;AACA,gB;AACA,I;AACA,K;AACA,kC;AACA,a;AACA,yB;AACA,yB;AACA,sB;AACA,0D;AACA,K;AACA,mD;AACA,oC;AACA,gC;AACA,I;AACA,K;AACA,8B;AACA,a;AACA,yB;AACA,qB;AACA,I;AACA,+D;AACA,K;AACA,sC;AACA,oE;AACA,oC;AACA,+B;AACA,iC;AACA,uB;AACA,2C;AACA,4B;AACA,qF;AACA,8D;AACA,S;AACA,kC;AACA,iD;AACA,gC;AACA,gB;AACA,6C;AACA,qC;AACA,8C;AACA,iE;AACA,iC;AACA,wE;AACA,iC;AACA,W;AACA,S;AACA,kC;AACA,O;AACA,O;AACA,kB;AACA,I;AACA,K;AACA,kC;AACA,a;AACA,yB;AACA,wB;AACA,I;AACA,mF;AACA,K;AACA,8C;AACA,0B;AACA,uC;AACA,6B;AACA,kD;AACA,iD;AACA,qC;AACA,a;AACA,+D;AACA,gC;AACA,6B;AACA,S;AACA,S;AACA,K;AACA,I;AACA,K;AACA,gC;AACA,a;AACA,yB;AACA,wB;AACA,I;AACA,mC;AACA,K;AACA,4D;AACA,0B;AACA,uC;AACA,6B;AACA,4C;AACA,mC;AACA,a;AACA,wC;AACA,qD;AACA,8H;AACA,a;AACA,2C;AACA,4B;AACA,kB;AACA,kC;AACA,6B;AACA,W;AACA,S;AACA,S;AACA,K;AACA,I;AACA,K;AACA,+C;AACA,a;AACA,6B;AACA,2B;AACA,I;AACA,sF;AACA,kF;AACA,K;AACA,oF;AACA,oC;AACA,4C;AACA,a;AACA,uC;AACA,kB;AACA,c;AACA,uH;AACA,O;AACA,K;AACA,wE;AACA,wD;AACA,qB;AACA,0D;AACA,yC;AACA,c;AACA,oS;AACA,O;AACA,K;AACA,8D;AACA,+G;AACA,I;AACA,K;AACA,iD;AACA,a;AACA,sB;AACA,sB;AACA,I;AACA,uE;AACA,K;AACA,4E;AACA,6F;AACA,I;AACA,K;AACA,sC;AACA,a;AACA,iC;AACA,sB;AACA,I;AACA,0D;AACA,K;AACA,6D;AACA,mD;AACA,4B;AACA,I;AACA,K;AACA,sC;AACA,a;AACA,iC;AACA,sB;AACA,I;AACA,0D;AACA,K;AACA,6D;AACA,uC;AACA,mB;;AAEA,0E;AACA,oC;AACA,uE;AACA,kC;AACA,I;AACA,K;AACA,sC;AACA,a;AACA,wB;AACA,qB;AACA,I;AACA,+D;AACA,K;AACA,qD;AACA,kC;AACA,iB;AACA,kB;AACA,K;AACA,2B;AACA,iB;AACA,kB;AACA,K;AACA,kD;AACA,I;AACA,K;AACA,yC;AACA,a;AACA,wB;AACA,qB;AACA,I;AACA,wF;AACA,K;AACA,2D;AACA,qC;AACA,iB;AACA,kB;AACA,K;AACA,8B;AACA,iB;AACA,kB;AACA,K;AACA,qD;AACA,I;AACA,K;AACA,sE;AACA,a;AACA,wB;AACA,qB;AACA,I;AACA,8F;AACA,+F;AACA,2G;AACA,I;AACA,sI;AACA,kJ;AACA,K;AACA,qH;AACA,qE;AACA,I;AACA,K;AACA,uE;AACA,a;AACA,gC;AACA,sB;AACA,I;AACA,8F;AACA,K;AACA,6H;AACA,uC;AACA,mB;;AAEA,+C;AACA,6C;AACA,mE;AACA,4D;AACA,wH;AACA,I;AACA,K;AACA,2D;AACA,a;AACA,uC;AACA,kH;AACA,qB;AACA,I;AACA,6D;AACA,K;AACA,6G;AACA,yB;AACA,2F;AACA,kC;AACA,yC;AACA,uC;AACA,0H;AACA,O;AACA,uB;AACA,K;AACA,iD;AACA,I;AACA,K;AACA,6D;AACA,a;AACA,8B;AACA,sB;AACA,I;AACA,gF;AACA,K;AACA,uG;AACA,qC;AACA,mB;;AAEA,6C;AACA,2C;AACA,2D;AACA,uG;AACA,I;AACA,K;AACA,qC;AACA,a;AACA,kG;AACA,mH;AACA,+C;AACA,I;AACA,6G;AACA,oG;AACA,qG;AACA,mD;AACA,K;AACA,sE;AACA,4B;AACA,uC;AACA,uC;AACA,oF;;AAEA,wE;AACA,8B;AACA,oE;AACA,iD;AACA,Y;AACA,6C;AACA,K;;AAEA,gD;;AAEA,2D;AACA,yD;AACA,kC;AACA,mC;AACA,4B;AACA,O;AACA,Y;AACA,gE;AACA,0D;AACA,+D;AACA,4B;AACA,8D;AACA,mD;AACA,wF;AACA,oC;AACA,4B;AACA,mC;AACA,gB;AACA,8B;AACA,S;AACA,O;AACA,K;;AAEA,Y;AACA,mB;AACA,iB;AACA,gB;AACA,M;AACA,I;AACA,K;AACA,kC;AACA,a;AACA,yE;AACA,uF;AACA,K;AACA,0D;AACA,gC;AACA,4C;AACA,+B;AACA,oC;AACA,Y;AACA,e;AACA,K;AACA,G;AACA,E;;;AAGA,0B;AACA,kD;AACA,yC;AACA,8C;AACA,8B;AACA,M;AACA,U;AACA,8C;AACA,4D;AACA,0C;AACA,M;AACA,G;AACA,C;;AAEA,iD;AACA,sC;AACA,E;AACA,mB;AACA,qB;AACA,G;AACA,mC;AACA,4E;AACA,E;;;;;;;;;;;;;;;;;;;ACpiBA,G;AACA,e;AACA,W;AACA,gC;AACA,E;AACA,sE;AACA,0D;AACA,G;AACA,gE;AACA,kB;AACA,kC;AACA,2E;AACA,4B;AACA,+B;AACA,uB;AACA,uC;AACA,yE;AACA,kD;AACA,yD;AACA,O;AACA,G;AACA,E;;AAEA,wD;AACA,kB;AACA,+C;AACA,iB;AACA,M;AACA,2C;AACA,E;;AAEA,uE;AACA,8C;AACA,E;;AAEA,2D;AACA,sC;AACA,yC;AACA,E;;AAEA,yD;AACA,kB;AACA,4B;AACA,+B;AACA,E;;AAEA,mE;AACA,kB;AACA,W;AACA,gE;AACA,iC;AACA,K;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;;ACrDA,oD;;AAEA,S;AACA,W;AACA,W;AACA,e;AACA,c;AACA,kB;AACA,kB;AACA,iB;AACA,kB;AACA,gB;AACA,oB;AACA,iB;AACA,G;AACA,E;;AAEA,2E;AACA,qB;AACA,qF;AACA,qC;AACA,qF;AACA,K;AACA,gG;AACA,sC;AACA,K;;AAEA,oB;AACA,kF;AACA,qC;AACA,oF;AACA,K;AACA,6F;AACA,qC;AACA,K;;AAEA,wB;AACA,uI;AACA,sB;AACA,8C;AACA,oG;AACA,O;;AAEA,mB;AACA,+B;AACA,O;;AAEA,wC;AACA,K;AACA,K;AACA,E;;AAEA,2D;AACA,W;AACA,gB;AACA,kG;AACA,gE;AACA,U;AACA,6D;AACA,iC;AACA,G;AACA,qB;AACA,E;;;;;;;;;;;;;;;;;;;AC9DA,mB;AACA,6B;AACA,yC;AACA,uB;AACA,uB;AACA,e;AACA,+B;AACA,gB;AACA,I;AACA,G;AACA,kC;AACA,0C;AACA,G;AACA,wB;AACA,oB;AACA,G;AACA,uD;AACA,qB;AACA,6B;AACA,G;AACA,0D;AACA,mB;AACA,4B;AACA,qB;AACA,G;AACA,G;AACA,oD;AACA,iB;AACA,uB;AACA,4B;AACA,wB;AACA,sB;AACA,sC;AACA,wB;AACA,U;AACA,G;AACA,G;AACA,mC;AACA,4B;AACA,qB;AACA,G;AACA,G;AACA,qD;AACA,0D;AACA,uB;AACA,uB;AACA,e;AACA,+B;AACA,gB;AACA,G;AACA,G;AACA,+B;AACA,sC;AACA,G;AACA,kC;AACA,uB;AACA,uC;AACA,0D;AACA,iE;AACA,wB;AACA,U;AACA,e;AACA,G;AACA,G;AACA,sC;AACA,uB;AACA,iE;AACA,uE;AACA,iE;AACA,wB;AACA,U;AACA,e;AACA,G;AACA,G;AACA,4C;AACA,uB;AACA,iE;AACA,6D;AACA,kD;AACA,gE;AACA,wC;AACA,0C;AACA,2H;AACA,Q;AACA,kD;AACA,W;AACA,gC;AACA,I;AACA,U;AACA,e;AACA,G;AACA,G;AACA,mC;AACA,qB;AACA,G;AACA,mC;AACA,c;AACA,G;AACA,mC;AACA,a;AACA,oB;AACA,E;AACA,E;;AAEA,oC;AACA,iD;AACA,+C;AACA,4C;AACA,0D;AACA,gE;AACA,kE;AACA,8E;AACA,2E;AACA,uF;AACA,E;;AAEA,kF;AACA,4C;AACA,sE;AACA,gD;;AAEA,gD;AACA,kD;AACA,6B;AACA,6B;AACA,6D;AACA,G;;AAEA,sE;AACA,0E;AACA,wC;AACA,+D;AACA,oB;AACA,kB;AACA,qB;AACA,4B;AACA,wB;AACA,yB;AACA,iC;AACA,c;AACA,8B;AACA,O;AACA,Y;AACA,sB;AACA,K;AACA,gF;AACA,mB;AACA,8E;AACA,iB;AACA,kD;AACA,sB;AACA,qC;AACA,oB;AACA,mC;AACA,kB;AACA,sC;AACA,qB;AACA,8B;AACA,6B;AACA,8B;AACA,Y;AACA,gC;AACA,K;AACA,G;AACA,c;AACA,E;;;;;;;;;;;;;;;;;;ACrKA,0F;;AAEA,kC;AACA,iB;AACA,iB;AACA,E;;AAEA,2D;AACA,iB;;AAEA,wB;AACA,S;;AAEA,uB;AACA,kB;AACA,S;AACA,iC;AACA,G;AACA,G;AACA,E;;AAEA,wE;AACA,iB;AACA,uB;;AAEA,iB;AACA,U;AACA,2C;AACA,8C;AACA,S;AACA,U;AACA,6C;AACA,sC;AACA,E;AACA,E;;AAEA,wF;AACA,iB;AACA,mC;AACA,c;AACA,Y;AACA,0C;AACA,4C;AACA,kC;AACA,G;AACA,E;AACA,iB;AACA,E;;;;;;;;;;;;;;;;;;AC/CA,qF;AACA,mF;AACA,sD;;AAEA,0C;AACA,kB;AACA,iB;AACA,E;;AAEA,wG;AACA,wC;;AAEA,gF;AACA,2C;AACA,oC;AACA,kD;;AAEA,+E;AACA,kD;AACA,2C;AACA,kD;;AAEA,kD;AACA,E;;AAEA,+D;AACA,iB;;AAEA,uB;AACA,S;;AAEA,wB;AACA,E;;AAEA,8D;AACA,iB;AACA,uB;AACA,0B;AACA,E;;AAEA,4E;AACA,iB;AACA,uB;;AAEA,iC;AACA,iC;AACA,E;AACA,E;;AAEA,0H;AACA,iB;AACA,iC;;AAEA,4C;AACA,S;;AAEA,4G;AACA,sG;AACA,2E;AACA,8E;;AAEA,iE;AACA,oB;AACA,+C;AACA,uE;AACA,E;;AAEA,oB;AACA,uC;AACA,+F;AACA,0B;AACA,G;;AAEA,4C;AACA,8B;AACA,wC;AACA,+C;AACA,yC;AACA,E;;AAEA,0E;AACA,iB;AACA,uB;;AAEA,iC;AACA,8B;AACA,4B;AACA,I;AACA,E;;AAEA,uC;AACA,oC;AACA,2C;AACA,yC;AACA,E;;AAEA,iE;AACA,iB;AACA,mD;AACA,iC;AACA,I;AACA,E;;AAEA,qE;AACA,iB;AACA,wB;AACA,E;;AAEA,4E;AACA,iB;AACA,iC;AACA,wC;AACA,yC;AACA,E;;AAEA,sE;AACA,iB;AACA,iC;AACA,wC;AACA,uC;AACA,E;;AAEA,sE;AACA,iB;AACA,iC;AACA,wC;AACA,uC;AACA,E;;AAEA,oF;AACA,iB;AACA,iC;AACA,wC;AACA,8C;AACA,E;;AAEA,4G;AACA,iB;AACA,iC;AACA,wC;AACA,wF;AACA,+B;AACA,I;AACA,wE;AACA,E;;AAEA,0G;AACA,iB;AACA,iC;AACA,wC;AACA,gG;AACA,+B;AACA,K;AACA,sE;AACA,E;;AAEA,wH;AACA,kB;AACA,kC;;AAEA,wC;AACA,U;AACA,G;;AAEA,0D;AACA,wF;;AAEA,gC;AACA,iD;;AAEA,mE;AACA,sB;AACA,iD;AACA,yE;AACA,I;;AAEA,gG;;AAEA,gD;AACA,oC;AACA,2C;AACA,2C;AACA,G;AACA,E;;AAEA,iJ;AACA,kB;AACA,kC;;AAEA,wC;AACA,U;AACA,G;;AAEA,0D;AACA,wF;;AAEA,gC;AACA,yD;AACA,qC;AACA,4C;AACA,4C;AACA,G;AACA,C;;AAEA,E;AACA,U;AACA,G;AACA,mG;AACA,iB;AACA,0B;AACA,0B;AACA,uC;AACA,0B;AACA,oC;AACA,mC;AACA,I;;AAEA,uG;AACA,yB;AACA,yB;AACA,iC;AACA,sD;AACA,O;AACA,G;;AAEA,iB;AACA,C;;;;;;;;;;;;;;;;;;AClOA,+B;AACA,6C;AACA,wD;AACA,oG;AACA,2E;AACA,6E;AACA,oB;AACA,kC;AACA,8B;AACA,+B;AACA,qC;AACA,wB;AACA,kB;AACA,qB;AACA,sB;AACA,wB;AACA,qB;AACA,iB;AACA,mB;AACA,0B;AACA,mB;AACA,gB;AACA,gB;AACA,oB;AACA,sB;AACA,oB;AACA,E;;AAEA,Q;AACA,uC;AACA,yB;AACA,mC;AACA,sC;AACA,uC;AACA,yC;AACA,sC;AACA,kC;AACA,oC;AACA,2C;AACA,oC;AACA,iC;AACA,iC;AACA,qC;AACA,uC;AACA,qC;AACA,G;AACA,E;;AAEA,E;AACA,2B;AACA,G;;AAEA,kC;AACA,e;AACA,yC;AACA,wB;AACA,kD;;AAEA,gE;AACA,2F;AACA,gE;AACA,kD;AACA,+D;AACA,uD;AACA,wE;AACA,gC;AACA,8C;AACA,kD;AACA,oC;AACA,6C;AACA,kC;AACA,a;AACA,W;AACA,wC;AACA,+B;AACA,kC;AACA,uC;AACA,oB;AACA,mC;AACA,a;AACA,W;AACA,uB;AACA,S;AACA,oB;AACA,S;AACA,O;AACA,K;;AAEA,a;AACA,C;;AAEA,uD;AACA,8G;AACA,yB;AACA,E;;AAEA,8D;AACA,kC;AACA,6C;AACA,+B;AACA,8C;AACA,4B;AACA,G;AACA,6B;AACA,oB;AACA,kC;AACA,mB;AACA,G;AACA,kC;AACA,yB;AACA,uC;AACA,wB;AACA,G;AACA,kC;AACA,yB;AACA,uC;AACA,wB;AACA,G;;AAEA,gC;AACA,+E;;AAEA,sB;AACA,+B;;AAEA,kE;AACA,+D;AACA,+C;AACA,6B;;AAEA,0E;AACA,mF;AACA,oF;AACA,4F;AACA,wE;AACA,6C;;AAEA,8C;AACA,iB;AACA,uB;AACA,kB;AACA,I;AACA,uD;AACA,8D;AACA,mD;AACA,K;;AAEA,6C;AACA,qF;AACA,oE;AACA,sC;AACA,gB;AACA,2E;AACA,wB;AACA,2B;AACA,qB;AACA,+B;AACA,8B;AACA,O;AACA,uE;AACA,uB;AACA,2B;AACA,qB;AACA,+B;AACA,8B;AACA,M;AACA,I;AACA,gB;AACA,E;;AAEA,E;AACA,qE;AACA,+D;AACA,qC;AACA,mC;AACA,2E;AACA,uC;AACA,G;AACA,wG;AACA,qC;AACA,yD;AACA,e;AACA,+C;AACA,sB;AACA,gC;AACA,O;AACA,K;;AAEA,wE;AACA,mE;AACA,2B;AACA,K;AACA,G;;AAEA,gD;AACA,uC;;AAEA,6B;AACA,8B;AACA,8D;AACA,kC;AACA,uC;AACA,+E;AACA,oD;AACA,sF;AACA,gB;AACA,+D;AACA,+D;AACA,6D;AACA,gC;AACA,kD;AACA,S;AACA,O;AACA,8B;AACA,4B;AACA,Y;AACA,iB;AACA,K;AACA,G;;AAEA,uE;AACA,0C;AACA,oC;AACA,+B;AACA,Y;AACA,sB;AACA,K;AACA,G;;AAEA,uB;AACA,yB;AACA,uC;AACA,4B;AACA,O;AACA,U;AACA,+B;AACA,G;;AAEA,iD;AACA,6G;AACA,8C;AACA,G;;AAEA,iE;AACA,e;AACA,E;;AAEA,0G;AACA,6B;;AAEA,iE;AACA,yD;AACA,oE;AACA,8B;AACA,qB;AACA,kB;AACA,wB;AACA,kB;AACA,mB;AACA,qB;AACA,sB;AACA,uB;AACA,oB;AACA,kE;AACA,uB;AACA,sB;;AAEA,uD;AACA,oE;AACA,4B;AACA,G;;AAEA,8D;AACA,kC;AACA,4B;AACA,yC;AACA,4B;AACA,G;;AAEA,qE;AACA,qE;;AAEA,uC;AACA,8C;AACA,sD;AACA,K;AACA,G;;AAEA,+B;AACA,qC;AACA,yB;AACA,2B;AACA,+B;AACA,2C;AACA,8C;AACA,mC;;AAEA,6B;AACA,oC;AACA,2D;AACA,oB;AACA,qE;AACA,qE;AACA,O;;AAEA,sC;AACA,O;AACA,G;AACA,mE;AACA,qC;AACA,iD;AACA,oC;AACA,G;;AAEA,sD;AACA,2C;AACA,kC;AACA,G;;AAEA,qD;AACA,uD;AACA,sD;AACA,+C;AACA,+F;AACA,kC;AACA,a;;AAEA,6F;AACA,2F;AACA,iC;AACA,iG;AACA,kC;AACA,Y;AACA,0D;AACA,oC;AACA,K;AACA,K;;AAEA,iD;AACA,mD;;AAEA,kC;AACA,gB;;AAEA,gC;AACA,mC;;AAEA,sB;AACA,6E;AACA,oB;AACA,8D;AACA,mC;AACA,+E;AACA,K;AACA,oC;AACA,oB;AACA,kI;AACA,yB;AACA,gC;AACA,O;AACA,wE;AACA,yC;AACA,yB;AACA,0B;AACA,6B;AACA,oB;AACA,uE;AACA,gF;AACA,6D;AACA,kB;AACA,0B;AACA,yB;AACA,W;AACA,O;AACA,K;AACA,8B;AACA,yC;AACA,0H;AACA,uB;AACA,wB;AACA,yB;AACA,yB;AACA,qE;AACA,8E;AACA,2D;AACA,uB;AACA,2B;AACA,uB;AACA,S;AACA,O;AACA,wC;AACA,gF;AACA,gC;AACA,K;AACA,uB;AACA,+C;AACA,wF;AACA,wC;AACA,K;AACA,uB;AACA,oH;;AAEA,oE;AACA,6B;AACA,0E;;AAEA,yB;AACA,c;AACA,S;AACA,0B;AACA,yB;AACA,uE;AACA,gF;AACA,6D;AACA,uB;AACA,2B;AACA,4B;AACA,yB;AACA,U;AACA,S;AACA,0B;AACA,wB;AACA,uE;AACA,gF;AACA,6D;AACA,sB;AACA,0B;AACA,2B;AACA,yB;AACA,S;AACA,Q;AACA,K;AACA,I;AACA,2E;AACA,8B;AACA,Y;AACA,6J;AACA,gC;AACA,0B;AACA,4B;AACA,K;AACA,U;AACA,2B;AACA,wB;AACA,oB;AACA,8E;AACA,8B;AACA,S;AACA,8E;AACA,8B;AACA,S;AACA,oE;AACA,kC;AACA,S;AACA,c;AACA,kB;AACA,0E;AACA,2D;AACA,S;AACA,0E;AACA,2D;AACA,S;AACA,c;AACA,sB;AACA,0E;AACA,wF;AACA,S;AACA,0E;AACA,wF;AACA,S;AACA,c;AACA,4B;AACA,0E;AACA,6G;AACA,S;AACA,0E;AACA,6G;AACA,S;AACA,c;AACA,oB;AACA,qC;AACA,0E;AACA,mC;AACA,gF;AACA,S;AACA,K;;AAEA,kD;AACA,sC;AACA,2F;AACA,e;AACA,gC;AACA,K;;AAEA,0B;AACA,uB;AACA,G;;AAEA,mF;AACA,wB;;AAEA,c;AACA,E;;AAEA,4D;AACA,kB;AACA,iB;AACA,yB;AACA,yC;AACA,mC;AACA,6B;AACA,2C;AACA,qC;AACA,iC;AACA,qC;AACA,I;;AAEA,0B;AACA,sC;AACA,E;AACA,8C;AACA,E;;AAEA,8E;AACA,gD;AACA,oF;AACA,qC;AACA,0C;AACA,E;;AAEA,4E;AACA,uC;AACA,gB;AACA,W;AACA,gD;AACA,uE;AACA,K;AACA,E;;AAEA,gE;AACA,6D;AACA,6B;AACA,E;;;;;;;;;;;;;;;;;;;;AC7hBA,iC;AACA,sE;AACA,kB;AACA,0C;AACA,uD;AACA,2C;AACA,kF;AACA,iB;AACA,qE;AACA,6C;AACA,gD;AACA,qB;AACA,6C;AACA,2D;AACA,W;AACA,S;AACA,mB;AACA,c;AACA,I;;;;;;;;;;;;;;;;;;;ACnBA,2B;AACA,oC;AACA,gC;;AAEA,8E;AACA,qD;AACA,kE;AACA,wC;AACA,K;AACA,4E;AACA,+B;AACA,yF;AACA,yF;AACA,sH;AACA,I;AACA,2D;AACA,uB;AACA,6C;AACA,wD;AACA,iE;;AAEA,6D;AACA,wD;AACA,iC;AACA,kF;AACA,kE;AACA,K;;AAEA,a;AACA,iD;AACA,kB;AACA,sC;AACA,qC;AACA,yC;AACA,wF;AACA,oD;AACA,S;AACA,oF;AACA,qB;AACA,mC;AACA,iC;AACA,Y;AACA,iC;AACA,K;;AAEA,qB;AACA,iC;AACA,iE;AACA,4C;AACA,sB;AACA,6B;AACA,Y;AACA,uB;AACA,8C;AACA,K;;AAEA,wE;AACA,8B;AACA,qB;AACA,6B;AACA,a;AACA,qD;AACA,+B;AACA,iB;AACA,4F;AACA,+B;AACA,yC;AACA,qC;AACA,yB;AACA,6B;AACA,uC;AACA,qD;AACA,sC;AACA,O;;AAEA,yC;AACA,wC;;AAEA,yF;AACA,0D;AACA,mC;;AAEA,uF;AACA,yC;AACA,wB;AACA,G;AACA,G;;AAEA,wD;AACA,kB;AACA,6C;AACA,8B;AACA,+B;AACA,E;;AAEA,4D;AACA,kB;AACA,wB;AACA,6C;;AAEA,mC;AACA,8B;AACA,iC;AACA,G;;AAEA,0B;AACA,yB;AACA,4B;AACA,G;;AAEA,kC;AACA,mC;;AAEA,6B;AACA,2B;AACA,8B;AACA,G;;AAEA,iC;AACA,sC;AACA,E;;;;;;;;;;;;;;;;;;;ACvHA,kC;AACA,wE;AACA,kB;AACA,oC;AACA,iF;AACA,iB;AACA,kD;AACA,8H;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACtBA,4B;AACA,iD;AACA,oE;AACA,kD;AACA,mG;;AAEA,Y;AACA,2C;AACA,iB;AACA,oC;AACA,6D;AACA,wB;AACA,+B;AACA,6C;AACA,0G;AACA,O;AACA,M;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACjBA,qC;AACA,8E;AACA,kB;AACA,oC;AACA,6E;AACA,4B;AACA,Q;AACA,iB;AACA,kD;AACA,iI;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACxBA,+B;AACA,uD;AACA,mE;AACA,2B;AACA,6C;AACA,oD;AACA,qB;AACA,6B;;AAEA,6C;AACA,wD;AACA,2B;AACA,qC;AACA,K;AACA,qF;;AAEA,Y;AACA,kB;AACA,M;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACnBA,wC;AACA,oF;AACA,kB;AACA,8C;AACA,6E;AACA,4B;AACA,Q;AACA,iB;AACA,8C;AACA,8C;AACA,mB;AACA,8C;AACA,0E;AACA,qB;AACA,uC;AACA,yB;AACA,4B;AACA,+E;AACA,Y;AACA,yC;AACA,+E;AACA,Y;AACA,oC;AACA,mB;AACA,uB;AACA,qB;AACA,yE;AACA,iD;AACA,oD;AACA,yB;AACA,iD;AACA,+D;AACA,e;AACA,a;AACA,uB;AACA,qB;AACA,iB;AACA,O;AACA,I;;;;;;;;;;;;;;;;;;;ACvCA,kC;AACA,0D;AACA,sE;AACA,6B;AACA,2B;;AAEA,wD;AACA,2B;AACA,qC;AACA,K;AACA,8F;AACA,I;AACA,+C;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACbA,qC;AACA,8E;AACA,kB;AACA,oC;AACA,6E;AACA,4B;AACA,Q;AACA,iB;AACA,kD;AACA,iJ;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACxBA,+B;AACA,2D;AACA,2C;AACA,I;AACA,uD;AACA,qF;AACA,kF;AACA,gG;;AAEA,qD;AACA,yE;AACA,mC;;AAEA,qB;AACA,sB;;AAEA,0D;;AAEA,2C;AACA,mG;AACA,8B;AACA,2C;AACA,K;;AAEA,oB;AACA,kD;;AAEA,sB;AACA,wH;;AAEA,0E;AACA,6D;AACA,I;AACA,6B;AACA,8H;;AAEA,gC;AACA,+H;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACtCA,qC;AACA,8E;AACA,kB;AACA,oC;AACA,Y;AACA,4C;AACA,M;AACA,iB;AACA,kD;AACA,iI;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;;ACvBA,sC;AACA,gF;AACA,kB;AACA,oC;AACA,6E;AACA,6B;AACA,8C;AACA,4C;AACA,Q;AACA,iB;AACA,kD;AACA,kI;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;AC1BA,gC;AACA,kD;AACA,G;;;;;;;;;;;;;;;;;;;ACDA,oC;AACA,4E;AACA,kB;AACA,oC;AACA,6E;AACA,4B;AACA,Q;AACA,iB;AACA,kD;AACA,gI;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACxBA,8B;AACA,sD;AACA,kE;AACA,Y;AACA,0C;AACA,mD;AACA,mD;AACA,+B;AACA,M;AACA,G;AACA,G;;AAEA,E;AACA,U;AACA,G;;AAEA,mC;AACA,+E;AACA,mB;AACA,oB;AACA,2B;AACA,I;AACA,yD;AACA,sC;AACA,wC;AACA,K;AACA,K;;AAEA,mB;AACA,C;;AAEA,mC;AACA,+E;AACA,0C;AACA,2C;AACA,4D;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;ACpCA,sC;AACA,gF;AACA,kB;AACA,oC;AACA,Y;AACA,4C;AACA,M;AACA,iB;AACA,kD;AACA,kI;AACA,mB;AACA,2D;AACA,gB;AACA,qD;AACA,iD;AACA,U;AACA,qB;AACA,6C;AACA,oD;AACA,W;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;;ACvBA,qC;AACA,8E;AACA,kB;AACA,8B;AACA,wE;AACA,4B;AACA,Q;AACA,iB;AACA,yF;AACA,iB;AACA,4C;AACA,+E;AACA,8B;AACA,U;AACA,mB;AACA,8F;AACA,mB;AACA,6F;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACrBA,+B;AACA,kD;AACA,mE;AACA,iF;AACA,0C;AACA,uE;AACA,I;AACA,4D;AACA,mE;AACA,gF;AACA,0C;AACA,sE;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACZA,sC;AACA,gF;AACA,kB;AACA,gC;AACA,6E;AACA,oD;AACA,wD;AACA,+D;AACA,Q;AACA,iB;AACA,kD;AACA,c;AACA,8C;AACA,Q;AACA,mB;AACA,yD;AACA,6D;AACA,qB;AACA,sE;AACA,qB;AACA,iB;AACA,K;AACA,I;;;;;;;;;;;;;;;;;;;ACvBA,gC;AACA,0D;AACA,gE;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;ACJA,qC;;AAEA,wC;AACA,sC;AACA,gC;AACA,C;;AAEA,E;AACA,iB;AACA,G;AACA,oE;AACA,oD;;AAEA,+E;AACA,G;;AAEA,E;AACA,mB;AACA,G;AACA,wE;AACA,sD;;AAEA,4E;AACA,G;;AAEA,E;AACA,iC;AACA,G;AACA,oG;AACA,oE;;AAEA,mG;AACA,gF;AACA,yC;AACA,G;;AAEA,E;AACA,iC;AACA,G;AACA,oG;AACA,oE;;AAEA,mG;AACA,gF;AACA,yC;AACA,G;;AAEA,E;AACA,iB;AACA,G;AACA,oE;AACA,oD;;AAEA,0E;AACA,wC;AACA,G;;AAEA,E;AACA,6B;AACA,G;AACA,qF;AACA,qB;AACA,kG;AACA,G;;AAEA,E;AACA,4B;AACA,G;AACA,mF;AACA,qB;AACA,iG;AACA,G;;AAEA,E;AACA,uB;AACA,G;AACA,gF;AACA,0D;;AAEA,0E;AACA,4E;AACA,G;;AAEA,E;AACA,mB;AACA,G;AACA,wE;AACA,sD;;AAEA,wC;AACA,G;;AAEA,E;AACA,e;AACA,G;AACA,gE;AACA,kD;AACA,sB;AACA,0B;;AAEA,4C;AACA,iC;AACA,kB;AACA,wJ;AACA,oB;AACA,4F;AACA,I;AACA,wE;AACA,+D;;AAEA,iE;AACA,oE;AACA,mD;AACA,gC;AACA,O;AACA,U;AACA,kG;AACA,sC;AACA,G;;AAEA,mE;AACA,sC;AACA,mB;AACA,8J;AACA,oD;AACA,4E;AACA,kD;AACA,kE;AACA,O;AACA,G;;AAEA,oC;AACA,sE;AACA,qC;;AAEA,mD;AACA,+D;AACA,mB;;AAEA,yE;AACA,gE;AACA,mB;;AAEA,yE;AACA,gE;AACA,mB;;AAEA,gB;AACA,K;;AAEA,+C;AACA,kC;;AAEA,mB;AACA,G;;AAEA,E;AACA,iB;AACA,G;AACA,uF;AACA,kB;AACA,E;AACA,yC;AACA,kE;AACA,sD;AACA,+C;AACA,8B;AACA,I;AACA,gC;AACA,sF;AACA,+D;AACA,K;AACA,G;;AAEA,+B;AACA,0G;;AAEA,4B;AACA,a;AACA,qB;AACA,+C;AACA,4B;AACA,oB;AACA,4K;AACA,K;AACA,G;;AAEA,gB;AACA,kD;AACA,4B;AACA,iG;AACA,K;AACA,G;;AAEA,iD;AACA,gB;AACA,G;;AAEA,E;AACA,U;AACA,G;;AAEA,4C;AACA,wC;AACA,8B;AACA,4C;AACA,+E;AACA,wD;AACA,uC;AACA,C;;;;;;;;;;;;;;;;;;ACjNA,oC;;AAEA,4F;AACA,4C;AACA,gB;;AAEA,6D;AACA,+D;AACA,2D;AACA,+D;AACA,oH;AACA,E;AACA,6D;;AAEA,uB;AACA,4C;AACA,iF;AACA,iD;AACA,wE;AACA,U;AACA,4D;AACA,yE;AACA,G;AACA,E;;AAEA,qF;AACA,Y;AACA,uD;AACA,0B;AACA,2B;AACA,oB;AACA,6B;AACA,gB;AACA,I;;AAEA,uE;AACA,sE;AACA,oD;AACA,iD;AACA,2B;AACA,kB;AACA,uB;AACA,uB;AACA,8B;AACA,K;;AAEA,a;AACA,0D;AACA,Y;AACA,uE;AACA,2B;AACA,+B;AACA,O;AACA,U;AACA,+D;AACA,2B;AACA,+B;AACA,O;AACA,G;AACA,E;;AAEA,0F;AACA,wC;AACA,6B;AACA,G;;AAEA,8B;AACA,2C;AACA,qC;AACA,6D;AACA,0B;;AAEA,kE;AACA,6B;AACA,G;;AAEA,4E;AACA,qD;;AAEA,2B;AACA,4C;AACA,2C;AACA,0B;AACA,U;AACA,2C;AACA,2B;AACA,G;;AAEA,wE;AACA,kB;AACA,8D;AACA,kC;;AAEA,4E;AACA,E;;AAEA,sD;AACA,wC;AACA,wF;AACA,2B;AACA,iC;AACA,4C;AACA,sB;AACA,sB;AACA,uE;AACA,O;AACA,Y;AACA,W;AACA,G;AACA,mB;AACA,kB;AACA,mE;AACA,G;AACA,E;;AAEA,mE;AACA,qE;AACA,oB;AACA,8D;AACA,kB;AACA,gC;AACA,qB;AACA,U;AACA,E;;AAEA,kE;AACA,kF;AACA,oC;AACA,uB;AACA,8F;AACA,gG;AACA,6B;AACA,sB;AACA,wD;AACA,kB;AACA,qB;AACA,O;AACA,O;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;AC3IA,+B;AACA,+B;;AAEA,wC;AACA,sC;AACA,W;AACA,2B;AACA,oD;AACA,qB;AACA,mD;AACA,6B;AACA,O;AACA,U;AACA,oG;AACA,mG;AACA,uB;AACA,mC;AACA,K;AACA,G;AACA,C;;AAEA,sC;AACA,sC;AACA,W;AACA,oE;AACA,6B;AACA,2B;AACA,kD;AACA,qB;AACA,iD;AACA,6B;AACA,O;AACA,U;AACA,oG;AACA,mG;AACA,uB;AACA,oC;AACA,K;AACA,G;AACA,C;;AAEA,0B;AACA,kE;AACA,iC;AACA,0C;AACA,gC;AACA,kD;AACA,kD;AACA,kD;AACA,mC;AACA,+D;AACA,mE;AACA,yC;AACA,qB;AACA,yC;AACA,qC;AACA,8B;AACA,mD;AACA,gB;;AAEA,kF;AACA,sB;AACA,mB;AACA,6F;AACA,wB;AACA,6F;AACA,K;;AAEA,4E;AACA,0B;AACA,6B;AACA,K;;AAEA,mB;AACA,wD;AACA,oD;;AAEA,mC;AACA,+B;AACA,6B;AACA,8B;AACA,qE;AACA,kC;AACA,K;;AAEA,iC;AACA,oD;AACA,uC;AACA,qC;AACA,e;AACA,wB;AACA,sD;AACA,gE;AACA,uC;AACA,sE;AACA,a;AACA,yC;AACA,gB;AACA,oD;AACA,S;AACA,6B;AACA,c;AACA,kD;AACA,O;AACA,kD;AACA,qD;AACA,S;AACA,uB;AACA,K;;AAEA,qC;AACA,iC;AACA,mB;AACA,qB;AACA,2B;AACA,uB;AACA,qB;AACA,oD;AACA,gC;AACA,+C;AACA,S;AACA,Q;AACA,6D;AACA,6D;AACA,oB;AACA,oC;AACA,wD;AACA,0C;AACA,wD;AACA,sD;AACA,e;AACA,gG;AACA,6F;AACA,kE;AACA,wC;AACA,wB;AACA,W;AACA,gB;AACA,mE;AACA,6B;AACA,8C;AACA,iD;AACA,W;AACA,0D;AACA,qD;AACA,a;AACA,S;AACA,0D;AACA,oD;AACA,W;AACA,uE;AACA,oC;AACA,Q;AACA,K;;AAEA,6C;AACA,qD;AACA,8B;AACA,sD;AACA,uD;AACA,oD;AACA,0B;AACA,gC;AACA,wB;;AAEA,oB;AACA,qD;AACA,oB;AACA,iB;AACA,S;;AAEA,qC;AACA,+B;AACA,iD;AACA,4B;AACA,2E;AACA,wC;AACA,kB;AACA,iC;AACA,+D;AACA,a;AACA,4B;AACA,W;AACA,U;AACA,mB;AACA,uB;AACA,6B;AACA,yB;AACA,uB;AACA,sD;AACA,kC;AACA,iD;AACA,Y;AACA,4B;AACA,U;;AAEA,mB;AACA,oB;AACA,wD;AACA,gB;AACA,iD;AACA,S;AACA,wD;AACA,gC;AACA,gC;AACA,6B;AACA,S;AACA,O;AACA,M;AACA,sB;AACA,K;;AAEA,+C;AACA,qD;AACA,qD;AACA,oC;AACA,kE;AACA,mE;AACA,qE;AACA,kE;AACA,8C;;AAEA,kD;;AAEA,4B;AACA,uE;AACA,oC;AACA,e;AACA,O;;AAEA,qC;AACA,iB;AACA,qB;AACA,2B;AACA,uB;AACA,qB;AACA,oD;AACA,gC;AACA,+C;AACA,U;AACA,2B;AACA,sB;AACA,wC;AACA,2E;AACA,wC;AACA,W;AACA,S;AACA,Q;;AAEA,gC;AACA,kE;AACA,qE;AACA,6D;AACA,6B;AACA,iD;AACA,sE;AACA,uD;AACA,4B;AACA,S;AACA,S;AACA,uB;AACA,+B;AACA,gC;AACA,O;AACA,K;;AAEA,6B;AACA,uD;AACA,uC;AACA,uC;;AAEA,mB;AACA,gD;AACA,+C;AACA,iD;AACA,qD;AACA,mC;AACA,yF;AACA,8F;AACA,mF;AACA,iC;AACA,W;AACA,wD;AACA,mB;AACA,6C;AACA,wB;AACA,O;AACA,gE;AACA,8B;AACA,kC;AACA,O;AACA,oG;AACA,qE;AACA,K;;AAEA,kE;AACA,6D;AACA,gE;AACA,yE;AACA,2C;AACA,kC;;AAEA,qE;AACA,gF;AACA,2C;AACA,8E;AACA,6E;AACA,6B;AACA,gC;AACA,0B;AACA,oC;AACA,kD;AACA,mC;AACA,M;;AAEA,yB;AACA,mB;AACA,kC;AACA,yE;AACA,kC;AACA,yF;AACA,mC;AACA,oD;AACA,yB;AACA,iG;AACA,iG;AACA,oE;AACA,gB;AACA,+F;AACA,oE;AACA,iC;AACA,iD;AACA,S;AACA,S;AACA,K;;AAEA,yB;AACA,wB;AACA,kC;AACA,yE;AACA,kC;AACA,+F;AACA,mC;AACA,oD;AACA,uF;AACA,qE;AACA,kC;AACA,S;AACA,yB;AACA,8E;AACA,S;AACA,K;;AAEA,yB;AACA,wB;AACA,sC;AACA,oB;AACA,wG;AACA,O;AACA,uE;AACA,sC;AACA,yF;AACA,oE;AACA,gE;AACA,qC;AACA,2B;AACA,gE;AACA,kC;AACA,sC;AACA,W;AACA,S;AACA,wC;AACA,kD;AACA,0B;AACA,mE;AACA,S;AACA,K;;AAEA,yB;AACA,8B;AACA,2B;AACA,6D;AACA,kE;AACA,K;AACA,I;AACA,6E;AACA,uE;AACA,sE;AACA,kH;AACA,+E;AACA,oH;AACA,K;AACA,I;AACA,2E;AACA,uE;AACA,6G;AACA,iJ;AACA,gH;AACA,K;AACA,I;AACA,kE;AACA,oB;;AAEA,2D;AACA,a;AACA,a;;AAEA,0C;AACA,gC;AACA,c;AACA,a;;AAEA,gE;AACA,sC;AACA,4E;AACA,kE;AACA,S;AACA,K;;AAEA,2E;AACA,uE;;AAEA,6E;AACA,8C;AACA,wB;AACA,gD;AACA,sC;AACA,a;AACA,K;;AAEA,kE;AACA,6G;AACA,iJ;AACA,gE;AACA,K;AACA,I;AACA,gE;AACA,0C;;AAEA,wC;;AAEA,yB;AACA,mC;;AAEA,8B;;AAEA,Y;AACA,a;;AAEA,gB;AACA,mD;AACA,sF;AACA,8E;AACA,K;;AAEA,iE;AACA,gE;AACA,uE;AACA,mB;AACA,6B;AACA,oC;AACA,wC;AACA,Y;AACA,oC;AACA,sE;AACA,sE;AACA,sC;AACA,qC;AACA,4C;AACA,8C;AACA,4C;AACA,S;AACA,Y;AACA,K;;AAEA,I;AACA,oE;AACA,qE;AACA,uE;AACA,2B;AACA,+B;AACA,6B;AACA,K;AACA,I;AACA,oF;AACA,gH;;AAEA,2B;;AAEA,mC;AACA,+D;AACA,+D;AACA,2B;AACA,6B;AACA,kD;AACA,iC;;AAEA,iC;AACA,qF;AACA,I;AACA,8E;AACA,2B;;AAEA,wE;AACA,yD;AACA,qC;AACA,+C;AACA,oF;AACA,oF;AACA,6B;AACA,kD;AACA,iC;;AAEA,qE;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACngBA,6C;;AAEA,qC;;AAEA,qC;;AAEA,G;AACA,4B;AACA,U;AACA,6J;AACA,qJ;AACA,uB;AACA,E;AACA,2G;AACA,Q;AACA,G;AACA,wE;AACA,oC;AACA,wB;AACA,G;;AAEA,yC;AACA,iB;AACA,uD;AACA,U;AACA,uC;;AAEA,8C;AACA,kD;AACA,mB;AACA,kB;AACA,sB;AACA,sB;AACA,qB;AACA,sB;AACA,oB;AACA,wB;AACA,qB;AACA,Q;;AAEA,+D;AACA,O;AACA,G;AACA,E;;AAEA,G;AACA,yB;AACA,U;AACA,wB;AACA,uB;AACA,E;AACA,sF;AACA,Q;AACA,G;AACA,yD;AACA,4C;AACA,iD;AACA,K;AACA,E;;AAEA,G;AACA,6B;AACA,U;AACA,yB;AACA,0F;AACA,uB;AACA,E;AACA,oH;AACA,G;AACA,mE;AACA,+C;AACA,wC;AACA,kC;AACA,G;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,2B;AACA,G;AACA,6E;AACA,6B;AACA,iC;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,E;AACA,Y;AACA,G;AACA,qE;AACA,gC;AACA,yB;AACA,E;;AAEA,G;AACA,6C;AACA,U;AACA,uB;AACA,2B;AACA,G;AACA,iG;AACA,yC;AACA,sD;AACA,G;AACA,8D;AACA,mN;AACA,G;AACA,wC;AACA,4C;AACA,E;;AAEA,G;AACA,6C;AACA,U;AACA,uB;AACA,iC;AACA,E;AACA,Y;AACA,G;AACA,uF;AACA,yC;AACA,sD;AACA,G;AACA,2C;AACA,oC;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,2F;AACA,mB;AACA,E;AACA,4F;AACA,4F;AACA,+E;AACA,G;AACA,iE;AACA,uC;AACA,wC;AACA,sH;AACA,G;AACA,yE;AACA,wD;AACA,8B;AACA,+D;AACA,6C;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,2F;AACA,wF;AACA,gB;AACA,E;AACA,sG;AACA,uG;AACA,G;AACA,4E;AACA,gD;AACA,gG;AACA,+C;AACA,4C;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,yG;AACA,sB;AACA,E;AACA,mF;AACA,yB;AACA,G;AACA,uE;AACA,+C;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,oF;AACA,8F;AACA,8L;AACA,iC;AACA,E;AACA,0F;AACA,iE;AACA,G;AACA,uF;AACA,uC;AACA,wC;AACA,sH;AACA,G;;AAEA,+D;AACA,E;;AAEA,G;AACA,gC;AACA,U;AACA,oF;AACA,iC;AACA,E;AACA,yF;AACA,iE;AACA,G;AACA,+D;AACA,uC;AACA,wC;AACA,qH;AACA,G;;AAEA,8B;AACA,iE;AACA,uC;AACA,mB;;AAEA,2B;AACA,qD;;AAEA,sD;;AAEA,0B;AACA,kD;AACA,iB;AACA,U;AACA,gB;AACA,G;AACA,E;;AAEA,G;AACA,wC;AACA,U;AACA,wG;AACA,sF;AACA,E;AACA,4E;AACA,+D;AACA,G;AACA,+E;AACA,8B;AACA,iE;AACA,uC;AACA,mB;AACA,iC;AACA,E;;AAEA,G;AACA,wB;AACA,U;AACA,8D;AACA,E;AACA,qI;AACA,G;AACA,6C;AACA,gB;AACA,M;AACA,6B;AACA,0B;AACA,uB;AACA,0F;AACA,G;AACA,gB;AACA,E;;AAEA,G;AACA,yB;AACA,U;AACA,E;AACA,6E;AACA,G;AACA,2C;AACA,4B;AACA,yB;AACA,2B;AACA,oD;AACA,+D;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,kC;AACA,U;AACA,uB;AACA,uB;AACA,gC;AACA,E;AACA,yB;AACA,G;AACA,qC;;AAEA,G;AACA,gC;AACA,gE;AACA,U;AACA,8J;AACA,E;AACA,kF;AACA,G;AACA,qC;;AAEA,G;AACA,qC;AACA,U;AACA,8D;AACA,yJ;AACA,oB;AACA,E;AACA,8H;AACA,uD;AACA,G;AACA,iF;AACA,S;AACA,iB;AACA,qB;AACA,G;AACA,Y;AACA,4B;AACA,G;AACA,mC;AACA,E;;AAEA,G;AACA,gC;AACA,U;AACA,gE;AACA,qB;AACA,E;AACA,4H;AACA,G;AACA,qC","sourcesContent":["// This is the only file that is run on the server, too\n\n// Extend the schema options allowed by SimpleSchema\nSimpleSchema.extendOptions({\n  autoform: Match.Optional(Object)\n});","\nTemplate.__checkName(\"quickForm_bootstrap3\");\nTemplate[\"quickForm_bootstrap3\"] = new Template(\"Template.quickForm_bootstrap3\", (function() {\n  var view = this;\n  return Blaze._TemplateWith(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"qfAutoFormContext\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"autoForm\"), function() {\n      return [ \"\\n    \", Blaze._TemplateWith(function() {\n        return {\n          fields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"fields\")),\n          omitFields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"omitFields\"))\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n      }), \"\\n    \", Blaze.If(function() {\n        return Spacebars.call(view.lookup(\"qfShouldRenderButton\"));\n      }, function() {\n        return [ \"\\n    \", HTML.DIV(\"\\n      \", HTML.BUTTON(HTML.Attrs(function() {\n          return Spacebars.attrMustache(view.lookup(\"submitButtonAtts\"));\n        }), \"\\n      \", Spacebars.With(function() {\n          return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"buttonContent\"));\n        }, function() {\n          return [ \"\\n      \", Blaze.View(function() {\n            return Spacebars.mustache(view.lookup(\".\"));\n          }), \"\\n      \" ];\n        }, function() {\n          return \"\\n      Submit\\n      \";\n        }), \"\\n      \"), \"\\n    \"), \"\\n    \" ];\n      }), \"\\n  \" ];\n    });\n  });\n}));\n\nTemplate.__checkName(\"afFieldLabel_bootstrap3\");\nTemplate[\"afFieldLabel_bootstrap3\"] = new Template(\"Template.afFieldLabel_bootstrap3\", (function() {\n  var view = this;\n  return HTML.LABEL(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }));\n}));\n\nTemplate.__checkName(\"afCheckbox_bootstrap3\");\nTemplate[\"afCheckbox_bootstrap3\"] = new Template(\"Template.afCheckbox_bootstrap3\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"checkbox\"\n  }, \"\\n    \", HTML.LABEL(\"\\n      \", HTML.INPUT(HTML.Attrs({\n    type: \"checkbox\",\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }, function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  })), \"\\n      \", Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"name\")\n    }));\n  }), \"\\n    \"), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afCheckboxGroup_bootstrap3\");\nTemplate[\"afCheckboxGroup_bootstrap3\"] = new Template(\"Template.afCheckboxGroup_bootstrap3\", (function() {\n  var view = this;\n  return Blaze.Each(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"items\"));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV({\n      \"class\": \"checkbox\"\n    }, \"\\n      \", HTML.LABEL(\"\\n        \", HTML.INPUT(HTML.Attrs({\n      type: \"checkbox\",\n      value: function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n      }\n    }, function() {\n      return Spacebars.attrMustache(view.lookup(\"atts\"));\n    })), \"\\n        \", Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"label\"));\n    }), \"\\n      \"), \"\\n    \"), \"\\n  \" ];\n  });\n}));\n\nTemplate.__checkName(\"afRadio_bootstrap3\");\nTemplate[\"afRadio_bootstrap3\"] = new Template(\"Template.afRadio_bootstrap3\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"radio\"\n  }, \"\\n    \", HTML.LABEL(\"\\n      \", HTML.INPUT(HTML.Attrs({\n    type: \"radio\",\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }, function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  })), \"\\n      \", Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"name\")\n    }));\n  }), \"\\n    \"), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afRadioGroup_bootstrap3\");\nTemplate[\"afRadioGroup_bootstrap3\"] = new Template(\"Template.afRadioGroup_bootstrap3\", (function() {\n  var view = this;\n  return Blaze.Each(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"items\"));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV({\n      \"class\": \"radio\"\n    }, \"\\n      \", HTML.LABEL(\"\\n        \", HTML.INPUT(HTML.Attrs({\n      type: \"radio\",\n      value: function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n      }\n    }, function() {\n      return Spacebars.attrMustache(view.lookup(\"atts\"));\n    })), \"\\n        \", Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"label\"));\n    }), \"\\n      \"), \"\\n    \"), \"\\n  \" ];\n  });\n}));\n\nTemplate.__checkName(\"afContenteditable_bootstrap3\");\nTemplate[\"afContenteditable_bootstrap3\"] = new Template(\"Template.afContenteditable_bootstrap3\", (function() {\n  var view = this;\n  return Spacebars.include(view.lookupTemplate(\"afContenteditable_plain\"));\n}));\n\nTemplate.__checkName(\"afFieldSelect_bootstrap3\");\nTemplate[\"afFieldSelect_bootstrap3\"] = new Template(\"Template.afFieldSelect_bootstrap3\", (function() {\n  var view = this;\n  return HTML.SELECT(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), \"\\n    \", Spacebars.With(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"contentBlockContext\"));\n  }, function() {\n    return [ \"\\n    \", Spacebars.include(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"contentBlock\"));\n    }), \"\\n    \" ];\n  }), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afSelect_bootstrap3\");\nTemplate[\"afSelect_bootstrap3\"] = new Template(\"Template.afSelect_bootstrap3\", (function() {\n  var view = this;\n  return HTML.SELECT(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), \"\\n    \", Blaze.Each(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"items\"));\n  }, function() {\n    return [ \"\\n      \", HTML.OPTION(HTML.Attrs(function() {\n      return Spacebars.attrMustache(view.lookup(\"optionAtts\"));\n    }), Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"label\"));\n    })), \"\\n    \" ];\n  }), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afTextarea_bootstrap3\");\nTemplate[\"afTextarea_bootstrap3\"] = new Template(\"Template.afTextarea_bootstrap3\", (function() {\n  var view = this;\n  return HTML.TEXTAREA(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }, {\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }));\n}));\n\nTemplate.__checkName(\"afInput_bootstrap3\");\nTemplate[\"afInput_bootstrap3\"] = new Template(\"Template.afInput_bootstrap3\", (function() {\n  var view = this;\n  return HTML.INPUT(HTML.Attrs({\n    type: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"type\"));\n    },\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }, function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }));\n}));\n\nTemplate.__checkName(\"afFormGroup_bootstrap3\");\nTemplate[\"afFormGroup_bootstrap3\"] = new Template(\"Template.afFormGroup_bootstrap3\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": function() {\n      return [ \"form-group \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n        }));\n      }, function() {\n        return \"has-error\";\n      }) ];\n    }\n  }, \"\\n    \", Blaze.Unless(function() {\n    return Spacebars.call(view.lookup(\"skipLabel\"));\n  }, function() {\n    return [ \"\\n    \", Blaze._TemplateWith(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"afFieldLabelAtts\"));\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"afFieldLabel\"));\n    }), \"\\n    \" ];\n  }), \"\\n    \", Blaze._TemplateWith(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"afFieldInputAtts\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afFieldInput\"));\n  }), \"\\n    \", HTML.SPAN({\n    \"class\": \"help-block\"\n  }, Blaze.View(function() {\n    return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    })));\n  })), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afObjectField_bootstrap3\");\nTemplate[\"afObjectField_bootstrap3\"] = new Template(\"Template.afObjectField_bootstrap3\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"panel panel-default\"\n  }, \"\\n    \", HTML.DIV({\n    \"class\": \"panel-heading\"\n  }, \"\\n      \", HTML.H3({\n    \"class\": \"panel-title\"\n  }, Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  })), \"\\n    \"), \"\\n    \", HTML.DIV({\n    \"class\": \"panel-body\"\n  }, \"\\n      \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }, function() {\n    return [ \"\\n      \", HTML.SPAN({\n      \"class\": \"help-block\"\n    }, Blaze.View(function() {\n      return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n        name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n      })));\n    })), \"\\n      \" ];\n  }), \"\\n      \", Blaze._TemplateWith(function() {\n    return {\n      name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")),\n      fields: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"fields\")),\n      omitFields: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"omitFields\"))\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n  }), \"\\n    \"), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afArrayField_bootstrap3\");\nTemplate[\"afArrayField_bootstrap3\"] = new Template(\"Template.afArrayField_bootstrap3\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": \"panel panel-default\"\n  }, \"\\n    \", HTML.DIV({\n    \"class\": \"panel-heading\"\n  }, Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  })), \"\\n    \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV({\n      \"class\": \"panel-body has-error\"\n    }, \"\\n      \", HTML.SPAN({\n      \"class\": \"help-block\"\n    }, Blaze.View(function() {\n      return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n        name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n      })));\n    })), \"\\n    \"), \"\\n    \" ];\n  }), \"\\n    \", HTML.UL({\n    \"class\": \"list-group\"\n  }, \"\\n      \", Blaze._TemplateWith(function() {\n    return {\n      name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")),\n      minCount: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\")),\n      maxCount: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\"))\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afEachArrayItem\"), function() {\n      return [ \"\\n      \", HTML.LI({\n        \"class\": \"list-group-item autoform-array-item\"\n      }, \"\\n        \", HTML.DIV({\n        \"class\": \"media\"\n      }, \"\\n          \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afArrayFieldHasMoreThanMinimum\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"name\"),\n          minCount: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"minCount\"),\n          maxCount: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"maxCount\")\n        }));\n      }, function() {\n        return [ \"\\n          \", HTML.BUTTON({\n          \"class\": \"btn btn-primary autoform-remove-item pull-left\"\n        }, HTML.SPAN({\n          \"class\": \"glyphicon glyphicon-minus\"\n        })), \"\\n          \" ];\n      }), \"\\n          \", HTML.DIV({\n        \"class\": \"media-body\"\n      }, \"\\n            \", Blaze._TemplateWith(function() {\n        return {\n          name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"name\")),\n          label: Spacebars.call(false),\n          options: Spacebars.call(\"auto\"),\n          fields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"fields\")),\n          omitFields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"omitFields\"))\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickField\"));\n      }), \"\\n          \"), \"\\n        \"), \"\\n      \"), \"\\n      \" ];\n    });\n  }), \"\\n      \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afArrayFieldHasLessThanMaximum\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\"),\n      minCount: Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\"),\n      maxCount: Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\")\n    }));\n  }, function() {\n    return [ \"\\n      \", HTML.LI({\n      \"class\": \"list-group-item\"\n    }, \"\\n        \", HTML.BUTTON({\n      \"class\": \"btn btn-primary autoform-add-item\",\n      \"data-autoform-field\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\"));\n      },\n      \"data-autoform-mincount\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\"));\n      },\n      \"data-autoform-maxcount\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\"));\n      }\n    }, HTML.SPAN({\n      \"class\": \"glyphicon glyphicon-plus\"\n    })), \"\\n      \"), \"\\n      \" ];\n  }), \"\\n    \"), \"\\n  \");\n}));\n","/*\n * Template helpers for \"bootstrap3\" template\n */\n\nTemplate['afFieldLabel_bootstrap3'].helpers({\n  atts: function bsFieldLabelAtts() {\n    var atts = (this || {}).atts;\n    var labelAtts = _.omit(atts, 'name', 'autoform', 'template');\n    // Add bootstrap class if necessary\n    if (typeof labelAtts['class'] === \"string\") {\n      labelAtts['class'] += \" control-label\"; //might be added twice but that shouldn't hurt anything\n    } else {\n      labelAtts['class'] = \"control-label\";\n    }\n    // Add \"for\" attribute if missing\n    labelAtts['for'] = labelAtts['for'] || atts['name'];\n    return labelAtts;\n  }\n});\n\nTemplate['quickForm_bootstrap3'].helpers({\n  submitButtonAtts: function bsQuickFormSubmitButtonAtts() {\n    var qfAtts = this.atts;\n    var atts = {type: \"submit\"};\n    if (typeof qfAtts.buttonClasses === \"string\") {\n      atts['class'] = qfAtts.buttonClasses;\n    } else {\n      atts['class'] = 'btn btn-primary';\n    }\n    return atts;\n  }\n});\n\nTemplate['afFormGroup_bootstrap3'].helpers({\n  skipLabel: function bsFormGroupSkipLabel() {\n    var self = this;\n\n    var type = AutoForm.getInputType(self.afFieldInputAtts);\n    return (self.skipLabel || type === \"boolean-checkbox\");\n  }\n});\n\nfunction addFormControlAtts() {\n  var atts = _.clone(this.atts);\n  if (typeof atts[\"class\"] === \"string\") {\n    atts[\"class\"] += \" form-control\";\n  } else {\n    atts[\"class\"] = \"form-control\";\n  }\n  return atts;\n}\n\nTemplate[\"afFieldSelect_bootstrap3\"].helpers({\n  atts: addFormControlAtts\n});\n\nTemplate[\"afSelect_bootstrap3\"].helpers({\n  atts: addFormControlAtts\n});\n\nTemplate[\"afTextarea_bootstrap3\"].helpers({\n  atts: addFormControlAtts\n});\n\nTemplate[\"afInput_bootstrap3\"].helpers({\n  atts: addFormControlAtts\n});\n\nfunction selectedAttsAdjust() {\n  var atts = _.clone(this.atts);\n  if (this.selected) {\n    atts.checked = \"\";\n  }\n  return atts;\n}\n\nTemplate[\"afCheckbox_bootstrap3\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afRadio_bootstrap3\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afCheckboxGroup_bootstrap3\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afRadioGroup_bootstrap3\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afSelect_bootstrap3\"].helpers({\n  optionAtts: function afSelectOptionAtts() {\n    var item = this;\n    var atts = {\n      value: item.value\n    };\n    if (item.selected) {\n      atts.selected = \"\";\n    }\n    return atts;\n  }\n});\n","\nTemplate.__checkName(\"afFieldLabel_bootstrap3-span\");\nTemplate[\"afFieldLabel_bootstrap3-span\"] = new Template(\"Template.afFieldLabel_bootstrap3-span\", (function() {\n  var view = this;\n  return HTML.SPAN(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }));\n}));\n","/*\n * Template helpers for \"bootstrap3-span\" template\n */\n\nTemplate['afFieldLabel_bootstrap3-span'].helpers({\n  atts: function bssAfFieldLabelAtts() {\n    var atts = (_.clone(this || {})).atts;\n    var spanAtts = _.omit(atts, 'name', 'autoform', 'template');\n    // Add bootstrap class if necessary; TODO use custom templates\n    if (typeof spanAtts['class'] === \"string\") {\n      spanAtts['class'] += \" control-label\"; //might be added twice but that shouldn't hurt anything\n    } else {\n      spanAtts['class'] = \"control-label\";\n    }\n    return spanAtts;\n  }\n});\n","\nTemplate.__checkName(\"quickForm_bootstrap3-horizontal\");\nTemplate[\"quickForm_bootstrap3-horizontal\"] = new Template(\"Template.quickForm_bootstrap3-horizontal\", (function() {\n  var view = this;\n  return Blaze._TemplateWith(function() {\n    return Spacebars.call(view.lookup(\"qfAutoFormContext\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"autoForm\"), function() {\n      return [ \"\\n    \", Blaze._TemplateWith(function() {\n        return {\n          fields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"fields\")),\n          omitFields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"omitFields\")),\n          template: Spacebars.call(\"bootstrap3-horizontal\"),\n          \"input-col-class\": Spacebars.call(view.lookup(\"inputClass\")),\n          \"label-class\": Spacebars.call(view.lookup(\"labelClass\"))\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n      }), \"\\n    \", Blaze.If(function() {\n        return Spacebars.call(view.lookup(\"qfShouldRenderButton\"));\n      }, function() {\n        return [ \"\\n    \", HTML.DIV({\n          \"class\": \"form-group\"\n        }, \"\\n      \", HTML.DIV({\n          \"class\": function() {\n            return Spacebars.mustache(view.lookup(\"labelClass\"));\n          }\n        }), \"\\n      \", HTML.DIV({\n          \"class\": function() {\n            return Spacebars.mustache(view.lookup(\"inputClass\"));\n          }\n        }, \"\\n        \", HTML.BUTTON(HTML.Attrs(function() {\n          return Spacebars.attrMustache(view.lookup(\"submitButtonAtts\"));\n        }), \"\\n        \", Spacebars.With(function() {\n          return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"buttonContent\"));\n        }, function() {\n          return [ \"\\n        \", Blaze.View(function() {\n            return Spacebars.mustache(view.lookup(\".\"));\n          }), \"\\n        \" ];\n        }, function() {\n          return \"\\n        Submit\\n        \";\n        }), \"\\n        \"), \"\\n      \"), \"\\n    \"), \"\\n    \" ];\n      }), \"\\n  \" ];\n    });\n  });\n}));\n\nTemplate.__checkName(\"afFormGroup_bootstrap3-horizontal\");\nTemplate[\"afFormGroup_bootstrap3-horizontal\"] = new Template(\"Template.afFormGroup_bootstrap3-horizontal\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": function() {\n      return [ \"form-group \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n        }));\n      }, function() {\n        return \"has-error\";\n      }) ];\n    }\n  }, \"\\n    \", Blaze.If(function() {\n    return Spacebars.call(view.lookup(\"skipLabel\"));\n  }, function() {\n    return [ \"\\n    \\n    \", HTML.LABEL(HTML.Attrs(function() {\n      return Spacebars.attrMustache(view.lookup(\"afEmptyFieldLabelAtts\"));\n    })), \"\\n    \" ];\n  }, function() {\n    return [ \"\\n    \", Blaze._TemplateWith(function() {\n      return Spacebars.call(view.lookup(\"afFieldLabelAtts\"));\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"afFieldLabel\"));\n    }), \"\\n    \" ];\n  }), \"\\n    \", HTML.DIV({\n    \"class\": function() {\n      return Spacebars.mustache(view.lookup(\"rightColumnClass\"));\n    }\n  }, \"\\n      \", Blaze._TemplateWith(function() {\n    return Spacebars.call(view.lookup(\"afFieldInputAtts\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afFieldInput\"));\n  }), \"\\n      \", HTML.SPAN({\n    \"class\": \"help-block\"\n  }, Blaze.View(function() {\n    return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    })));\n  })), \"\\n    \"), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afObjectField_bootstrap3-horizontal\");\nTemplate[\"afObjectField_bootstrap3-horizontal\"] = new Template(\"Template.afObjectField_bootstrap3-horizontal\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": function() {\n      return [ \"form-group \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n        }));\n      }, function() {\n        return \"has-error\";\n      }) ];\n    }\n  }, \"\\n    \", Blaze._TemplateWith(function() {\n    return Spacebars.call(view.lookup(\"afFieldLabelAtts\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afFieldLabel\"));\n  }), \"\\n    \", HTML.DIV({\n    \"class\": function() {\n      return Spacebars.mustache(view.lookup(\"rightColumnClass\"));\n    }\n  }, \"\\n      \", HTML.DIV({\n    \"class\": \"panel panel-default autoform-padding-fix\"\n  }, \"\\n        \", HTML.DIV({\n    \"class\": \"panel-body\"\n  }, \"\\n        \", Blaze._TemplateWith(function() {\n    return {\n      name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")),\n      fields: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"fields\")),\n      omitFields: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"omitFields\")),\n      template: Spacebars.call(\"bootstrap3\")\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n  }), \"\\n        \"), \"\\n      \"), \"\\n    \"), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afArrayField_bootstrap3-horizontal\");\nTemplate[\"afArrayField_bootstrap3-horizontal\"] = new Template(\"Template.afArrayField_bootstrap3-horizontal\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": function() {\n      return [ \"form-group \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n        }));\n      }, function() {\n        return \"has-error\";\n      }) ];\n    }\n  }, \"\\n    \", Blaze._TemplateWith(function() {\n    return Spacebars.call(view.lookup(\"afFieldLabelAtts\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afFieldLabel\"));\n  }), \"\\n    \", HTML.DIV({\n    \"class\": function() {\n      return Spacebars.mustache(view.lookup(\"rightColumnClass\"));\n    }\n  }, \"\\n      \", HTML.DIV({\n    \"class\": \"panel panel-default autoform-padding-fix\"\n  }, \"\\n        \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }, function() {\n    return [ \"\\n        \", HTML.DIV({\n      \"class\": \"panel-body has-error\"\n    }, \"\\n          \", HTML.SPAN({\n      \"class\": \"help-block\"\n    }, Blaze.View(function() {\n      return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n        name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n      })));\n    })), \"\\n        \"), \"\\n        \" ];\n  }), \"\\n        \", HTML.UL({\n    \"class\": \"list-group\"\n  }, \"\\n          \", Blaze._TemplateWith(function() {\n    return {\n      name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")),\n      minCount: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\")),\n      maxCount: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\"))\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afEachArrayItem\"), function() {\n      return [ \"\\n          \", HTML.LI({\n        \"class\": \"list-group-item autoform-array-item\"\n      }, \"\\n            \", HTML.DIV({\n        \"class\": \"media\"\n      }, \"\\n              \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afArrayFieldHasMoreThanMinimum\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"name\"),\n          minCount: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"minCount\"),\n          maxCount: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"maxCount\")\n        }));\n      }, function() {\n        return [ \"\\n              \", HTML.BUTTON({\n          \"class\": \"btn btn-primary autoform-remove-item pull-left\"\n        }, HTML.SPAN({\n          \"class\": \"glyphicon glyphicon-minus\"\n        })), \"\\n              \" ];\n      }), \"\\n              \", HTML.DIV({\n        \"class\": \"media-body\"\n      }, \"\\n                \", Blaze._TemplateWith(function() {\n        return {\n          name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"name\")),\n          label: Spacebars.call(false)\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickField\"));\n      }), \"\\n              \"), \"\\n            \"), \"\\n          \"), \"\\n          \" ];\n    });\n  }), \"\\n          \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afArrayFieldHasLessThanMaximum\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\"),\n      minCount: Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\"),\n      maxCount: Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\")\n    }));\n  }, function() {\n    return [ \"\\n          \", HTML.LI({\n      \"class\": \"list-group-item\"\n    }, \"\\n            \", HTML.BUTTON({\n      \"class\": \"btn btn-primary autoform-add-item\",\n      \"data-autoform-field\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\"));\n      },\n      \"data-autoform-mincount\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\"));\n      },\n      \"data-autoform-maxcount\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\"));\n      }\n    }, HTML.SPAN({\n      \"class\": \"glyphicon glyphicon-plus\"\n    })), \"\\n          \"), \"\\n          \" ];\n  }), \"\\n        \"), \"\\n      \"), \"\\n    \"), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afCheckbox_bootstrap3-horizontal\");\nTemplate[\"afCheckbox_bootstrap3-horizontal\"] = new Template(\"Template.afCheckbox_bootstrap3-horizontal\", (function() {\n  var view = this;\n  return Blaze.If(function() {\n    return Spacebars.call(view.lookup(\"useLeftLabel\"));\n  }, function() {\n    return [ \"\\n  \\n  \", HTML.DIV({\n      \"class\": \"checkbox\"\n    }, \"\\n    \", HTML.INPUT(HTML.Attrs({\n      type: \"checkbox\",\n      value: function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n      }\n    }, function() {\n      return Spacebars.attrMustache(view.lookup(\"attsPlusSpecialClass\"));\n    })), \"\\n  \"), \"\\n  \" ];\n  }, function() {\n    return [ \"\\n  \", HTML.DIV({\n      \"class\": \"checkbox\"\n    }, \"\\n    \", HTML.LABEL(\"\\n      \", HTML.INPUT(HTML.Attrs({\n      type: \"checkbox\",\n      value: function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n      }\n    }, function() {\n      return Spacebars.attrMustache(view.lookup(\"atts\"));\n    })), \"\\n      \", Blaze.View(function() {\n      return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n        name: Spacebars.dot(view.lookup(\".\"), \"name\")\n      }));\n    }), \"\\n    \"), \"\\n  \"), \"\\n  \" ];\n  });\n}));\n","function findAtts() {\n  var c, n = 0;\n  do {\n    c = UI._parentData(n++);\n  } while (c && !c.atts);\n  return c && c.atts;\n}\n\nTemplate['quickForm_bootstrap3-horizontal'].helpers({\n  inputClass: function inputClassHelper() {\n    var atts = findAtts();\n    if (atts) {\n      return atts[\"input-col-class\"];\n    }\n  },\n  labelClass: function labelClassHelper() {\n    var atts = findAtts();\n    if (atts) {\n      return atts[\"label-class\"];\n    }\n  },\n  submitButtonAtts: function bsQuickFormSubmitButtonAtts() {\n    var qfAtts = this.atts;\n    var atts = {type: \"submit\"};\n    if (typeof qfAtts.buttonClasses === \"string\") {\n      atts['class'] = qfAtts.buttonClasses;\n    } else {\n      atts['class'] = 'btn btn-primary';\n    }\n    return atts;\n  },\n  qfAutoFormContext: function () {\n    var ctx = _.clone(this.qfAutoFormContext || {});\n    if (typeof ctx[\"class\"] === \"string\") {\n      ctx[\"class\"] += \" form-horizontal\";\n    } else {\n      ctx[\"class\"] = \"form-horizontal\";\n    }\n    if (ctx[\"input-col-class\"])\n      delete ctx[\"input-col-class\"];\n    if (ctx[\"label-class\"])\n      delete ctx[\"label-class\"];\n    return ctx;\n  }\n});\n\nTemplate[\"afFormGroup_bootstrap3-horizontal\"].helpers({\n  afFieldInputAtts: function () {\n    var atts = _.clone(this.afFieldInputAtts || {});\n    if ('input-col-class' in atts) {\n      delete atts['input-col-class'];\n    }\n    // We have a special template for check boxes, but otherwise we\n    // want to use the same as those defined for bootstrap3 template.\n    if (AutoForm.getInputType(this.afFieldInputAtts) === \"boolean-checkbox\") {\n      atts.template = \"bootstrap3-horizontal\";\n    } else {\n      atts.template = \"bootstrap3\";\n    }\n    return atts;\n  },\n  afFieldLabelAtts: function () {\n    var atts = _.clone(this.afFieldLabelAtts || {});\n    atts.template = \"bootstrap3\";\n    return atts;\n  },\n  afEmptyFieldLabelAtts: function () {\n    var atts = _.clone(this.afFieldLabelAtts || {});\n    var labelAtts = _.omit(atts, 'name', 'autoform', 'template');\n    // Add bootstrap class if necessary\n    if (typeof labelAtts['class'] === \"string\") {\n      labelAtts['class'] += \" control-label\"; //might be added twice but that shouldn't hurt anything\n    } else {\n      labelAtts['class'] = \"control-label\";\n    }\n    return labelAtts;\n  },\n  rightColumnClass: function () {\n    var atts = this.afFieldInputAtts || {};\n    return atts['input-col-class'] || \"\";\n  },\n  skipLabel: function bshFormGroupSkipLabel() {\n    var self = this;\n\n    var type = AutoForm.getInputType(self.afFieldInputAtts);\n    return (self.skipLabel || (type === \"boolean-checkbox\" && !self.afFieldInputAtts.leftLabel));\n  }\n});\n\nTemplate[\"afObjectField_bootstrap3-horizontal\"].helpers({\n  rightColumnClass: function () {\n    var atts = this.atts || {};\n    return atts['input-col-class'] || \"\";\n  },\n  afFieldLabelAtts: function () {\n    var atts = this.atts;\n    return {\n      template: \"bootstrap3\",\n      \"class\": atts[\"label-class\"],\n      \"name\": atts.name\n    }\n  }\n});\n\nTemplate[\"afArrayField_bootstrap3-horizontal\"].helpers({\n  rightColumnClass: function () {\n    var atts = this.atts || {};\n    return atts['input-col-class'] || \"\";\n  },\n  afFieldLabelAtts: function () {\n    var atts = this.atts || {};\n    return {\n      template: \"bootstrap3\",\n      \"class\": atts[\"label-class\"],\n      \"name\": atts.name\n    };\n  }\n});\n\nTemplate[\"afCheckbox_bootstrap3-horizontal\"].helpers({\n  atts: function () {\n    var atts = _.clone(this.atts);\n    if (this.selected) {\n      atts.checked = \"\";\n    }\n    return atts;\n  },\n  attsPlusSpecialClass: function () {\n    var atts = _.clone(this.atts);\n    if (this.selected) {\n      atts.checked = \"\";\n    }\n    if (atts[\"class\"]) {\n      atts[\"class\"] += \" autoform-checkbox-margin-fix\";\n    } else {\n      atts[\"class\"] = \"autoform-checkbox-margin-fix\"\n    }\n    return atts;\n  },\n  useLeftLabel: function () {\n    return this.atts.leftLabel;\n  }\n});","\nTemplate.__checkName(\"quickForm_plain\");\nTemplate[\"quickForm_plain\"] = new Template(\"Template.quickForm_plain\", (function() {\n  var view = this;\n  return Blaze._TemplateWith(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"qfAutoFormContext\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"autoForm\"), function() {\n      return [ \"\\n    \", Blaze._TemplateWith(function() {\n        return {\n          fields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"fields\")),\n          omitFields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"omitFields\"))\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n      }), \"\\n    \", Blaze.If(function() {\n        return Spacebars.call(view.lookup(\"qfShouldRenderButton\"));\n      }, function() {\n        return [ \"\\n    \", HTML.DIV(\"\\n      \", HTML.BUTTON(HTML.Attrs(function() {\n          return Spacebars.attrMustache(view.lookup(\"submitButtonAtts\"));\n        }), \"\\n      \", Spacebars.With(function() {\n          return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"buttonContent\"));\n        }, function() {\n          return [ \"\\n      \", Blaze.View(function() {\n            return Spacebars.mustache(view.lookup(\".\"));\n          }), \"\\n      \" ];\n        }, function() {\n          return \"\\n      Submit\\n      \";\n        }), \"\\n      \"), \"\\n    \"), \"\\n    \" ];\n      }), \"\\n  \" ];\n    });\n  });\n}));\n\nTemplate.__checkName(\"afFieldLabel_plain\");\nTemplate[\"afFieldLabel_plain\"] = new Template(\"Template.afFieldLabel_plain\", (function() {\n  var view = this;\n  return HTML.LABEL(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }));\n}));\n\nTemplate.__checkName(\"afCheckbox_plain\");\nTemplate[\"afCheckbox_plain\"] = new Template(\"Template.afCheckbox_plain\", (function() {\n  var view = this;\n  return HTML.DIV(HTML.INPUT(HTML.Attrs({\n    type: \"checkbox\",\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }, function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  })), \" \", HTML.LABEL({\n    \"for\": function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"name\"));\n    }\n  }, Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"name\")\n    }));\n  })));\n}));\n\nTemplate.__checkName(\"afCheckboxGroup_plain\");\nTemplate[\"afCheckboxGroup_plain\"] = new Template(\"Template.afCheckboxGroup_plain\", (function() {\n  var view = this;\n  return Blaze.Each(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"items\"));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV(HTML.INPUT(HTML.Attrs({\n      type: \"checkbox\",\n      value: function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n      }\n    }, function() {\n      return Spacebars.attrMustache(view.lookup(\"atts\"));\n    })), \" \", HTML.LABEL({\n      \"for\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"name\"));\n      }\n    }, Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"label\"));\n    }))), \"\\n  \" ];\n  });\n}));\n\nTemplate.__checkName(\"afRadio_plain\");\nTemplate[\"afRadio_plain\"] = new Template(\"Template.afRadio_plain\", (function() {\n  var view = this;\n  return HTML.DIV(HTML.INPUT(HTML.Attrs({\n    type: \"checkbox\",\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }, function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  })), \" \", HTML.LABEL({\n    \"for\": function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"name\"));\n    }\n  }, Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"name\")\n    }));\n  })));\n}));\n\nTemplate.__checkName(\"afRadioGroup_plain\");\nTemplate[\"afRadioGroup_plain\"] = new Template(\"Template.afRadioGroup_plain\", (function() {\n  var view = this;\n  return Blaze.Each(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"items\"));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV(HTML.INPUT(HTML.Attrs({\n      type: \"checkbox\",\n      value: function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n      }\n    }, function() {\n      return Spacebars.attrMustache(view.lookup(\"atts\"));\n    })), \" \", HTML.LABEL({\n      \"for\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"name\"));\n      }\n    }, Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"label\"));\n    }))), \"\\n  \" ];\n  });\n}));\n\nTemplate.__checkName(\"afContenteditable_plain\");\nTemplate[\"afContenteditable_plain\"] = new Template(\"Template.afContenteditable_plain\", (function() {\n  var view = this;\n  return HTML.DIV(HTML.Attrs({\n    contenteditable: \"true\"\n  }, function() {\n    return Spacebars.attrMustache(Spacebars.dot(view.lookup(\".\"), \"atts\"));\n  }), Blaze.View(function() {\n    return Spacebars.makeRaw(Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\")));\n  }));\n}));\n\nTemplate.__checkName(\"afFieldSelect_plain\");\nTemplate[\"afFieldSelect_plain\"] = new Template(\"Template.afFieldSelect_plain\", (function() {\n  var view = this;\n  return HTML.SELECT(HTML.Attrs(function() {\n    return Spacebars.attrMustache(Spacebars.dot(view.lookup(\".\"), \"atts\"));\n  }), \"\\n    \", Spacebars.With(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"contentBlockContext\"));\n  }, function() {\n    return [ \"\\n    \", Spacebars.include(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"contentBlock\"));\n    }), \"\\n    \" ];\n  }), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afSelect_plain\");\nTemplate[\"afSelect_plain\"] = new Template(\"Template.afSelect_plain\", (function() {\n  var view = this;\n  return HTML.SELECT(HTML.Attrs(function() {\n    return Spacebars.attrMustache(Spacebars.dot(view.lookup(\".\"), \"atts\"));\n  }), \"\\n    \", Blaze.Each(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"items\"));\n  }, function() {\n    return [ \"\\n    \", HTML.OPTION(HTML.Attrs(function() {\n      return Spacebars.attrMustache(view.lookup(\"optionAtts\"));\n    }), Blaze.View(function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"label\"));\n    })), \"\\n    \" ];\n  }), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afTextarea_plain\");\nTemplate[\"afTextarea_plain\"] = new Template(\"Template.afTextarea_plain\", (function() {\n  var view = this;\n  return HTML.TEXTAREA(HTML.Attrs(function() {\n    return Spacebars.attrMustache(Spacebars.dot(view.lookup(\".\"), \"atts\"));\n  }, {\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }));\n}));\n\nTemplate.__checkName(\"afInput_plain\");\nTemplate[\"afInput_plain\"] = new Template(\"Template.afInput_plain\", (function() {\n  var view = this;\n  return HTML.INPUT(HTML.Attrs({\n    type: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"type\"));\n    },\n    value: function() {\n      return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"value\"));\n    }\n  }, function() {\n    return Spacebars.attrMustache(Spacebars.dot(view.lookup(\".\"), \"atts\"));\n  }));\n}));\n\nTemplate.__checkName(\"afFormGroup_plain\");\nTemplate[\"afFormGroup_plain\"] = new Template(\"Template.afFormGroup_plain\", (function() {\n  var view = this;\n  return HTML.DIV({\n    \"class\": function() {\n      return Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n        }));\n      }, function() {\n        return \"has-error\";\n      });\n    }\n  }, \"\\n    \", Blaze.Unless(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"skipLabel\"));\n  }, function() {\n    return [ \"\\n    \", Blaze._TemplateWith(function() {\n      return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"afFieldLabelAtts\"));\n    }, function() {\n      return Spacebars.include(view.lookupTemplate(\"afFieldLabel\"));\n    }), \"\\n    \" ];\n  }), \"\\n    \", Blaze._TemplateWith(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"afFieldInputAtts\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afFieldInput\"));\n  }), \"\\n    \", HTML.SPAN(Blaze.View(function() {\n    return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    })));\n  })), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afObjectField_plain\");\nTemplate[\"afObjectField_plain\"] = new Template(\"Template.afObjectField_plain\", (function() {\n  var view = this;\n  return HTML.FIELDSET(\"\\n    \", HTML.LEGEND(Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  })), \"\\n    \", Blaze._TemplateWith(function() {\n    return {\n      name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")),\n      fields: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"fields\")),\n      omitFields: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"omitFields\"))\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n  }), \"\\n  \");\n}));\n\nTemplate.__checkName(\"afArrayField_plain\");\nTemplate[\"afArrayField_plain\"] = new Template(\"Template.afArrayField_plain\", (function() {\n  var view = this;\n  return HTML.FIELDSET(\"\\n    \", HTML.LEGEND(Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  })), \"\\n    \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afFieldIsInvalid\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV({\n      \"class\": \"autoform-array-field-error\"\n    }, \"\\n      \", Blaze.View(function() {\n      return Spacebars.makeRaw(Spacebars.mustache(view.lookup(\"afFieldMessage\"), Spacebars.kw({\n        name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n      })));\n    }), \"\\n    \"), \"\\n    \" ];\n  }), \"\\n    \", Blaze._TemplateWith(function() {\n    return {\n      name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")),\n      minCount: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\")),\n      maxCount: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\"))\n    };\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"afEachArrayItem\"), function() {\n      return [ \"\\n    \", HTML.DIV({\n        \"class\": \"autoform-array-item\"\n      }, \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          name: Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"name\")),\n          label: Spacebars.call(false)\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickField\"));\n      }), \"\\n      \", Blaze.If(function() {\n        return Spacebars.dataMustache(view.lookup(\"afArrayFieldHasMoreThanMinimum\"), Spacebars.kw({\n          name: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"name\"),\n          minCount: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"minCount\"),\n          maxCount: Spacebars.dot(view.lookup(\"..\"), \"atts\", \"maxCount\")\n        }));\n      }, function() {\n        return [ \"\\n      \", HTML.BUTTON({\n          \"class\": \"autoform-remove-item\"\n        }, \"Remove\"), \"\\n      \" ];\n      }), \"\\n    \"), \"\\n    \" ];\n    });\n  }), \"\\n    \", Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"afArrayFieldHasLessThanMaximum\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\"),\n      minCount: Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\"),\n      maxCount: Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\")\n    }));\n  }, function() {\n    return [ \"\\n    \", HTML.DIV({\n      style: \"margin-top: 20px;\"\n    }, \"\\n      \", HTML.BUTTON({\n      \"class\": \"autoform-add-item\",\n      \"data-autoform-field\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\"));\n      },\n      \"data-autoform-mincount\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"minCount\"));\n      },\n      \"data-autoform-maxcount\": function() {\n        return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"atts\", \"maxCount\"));\n      }\n    }, \"Add\"), \"\\n    \"), \"\\n    \" ];\n  }), \"\\n  \");\n}));\n","/*\n * Template helpers for \"plain\" template\n */\n\nTemplate['afFieldLabel_plain'].helpers({\n  atts: function plFieldLabelAtts() {\n    var atts = (_.clone(this || {})).atts;\n    var labelAtts = _.omit(atts, 'name', 'autoform', 'template');\n    // Add \"for\" attribute if missing\n    labelAtts['for'] = labelAtts['for'] || atts['name'];\n    return labelAtts;\n  }\n});\n\nTemplate['quickForm_plain'].helpers({\n  submitButtonAtts: function plQuickFormSubmitButtonAtts() {\n    var qfAtts = this.atts;\n    var atts = {type: \"submit\"};\n    if (typeof qfAtts.buttonClasses === \"string\") {\n      atts['class'] = qfAtts.buttonClasses;\n    }\n    return atts;\n  }\n});\n\nfunction selectedAttsAdjust() {\n  var atts = _.clone(this.atts);\n  if (this.selected) {\n    atts.checked = \"\";\n  }\n  return atts;\n}\n\nTemplate[\"afCheckbox_plain\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afRadio_plain\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afCheckboxGroup_plain\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afRadioGroup_plain\"].helpers({\n  atts: selectedAttsAdjust\n});\n\nTemplate[\"afSelect_plain\"].helpers({\n  optionAtts: function afSelectOptionAtts() {\n    var item = this\n    var atts = {\n      value: item.value\n    };\n    if (item.selected) {\n      atts.selected = \"\";\n    }\n    return atts;\n  }\n});\n","\nTemplate.__checkName(\"quickForm_plain-fieldset\");\nTemplate[\"quickForm_plain-fieldset\"] = new Template(\"Template.quickForm_plain-fieldset\", (function() {\n  var view = this;\n  return Blaze._TemplateWith(function() {\n    return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"qfAutoFormContext\"));\n  }, function() {\n    return Spacebars.include(view.lookupTemplate(\"autoForm\"), function() {\n      return [ \"\\n    \", HTML.FIELDSET(\"\\n      \", Spacebars.With(function() {\n        return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"legend\"));\n      }, function() {\n        return [ \"\\n      \", HTML.LEGEND(Blaze.View(function() {\n          return Spacebars.mustache(view.lookup(\".\"));\n        })), \"\\n      \" ];\n      }), \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          fields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"fields\")),\n          omitFields: Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"omitFields\"))\n        };\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickFields\"));\n      }), \"\\n    \"), \"\\n    \", Blaze.If(function() {\n        return Spacebars.call(view.lookup(\"qfShouldRenderButton\"));\n      }, function() {\n        return [ \"\\n    \", HTML.DIV(\"\\n      \", HTML.BUTTON(HTML.Attrs(function() {\n          return Spacebars.attrMustache(view.lookup(\"submitButtonAtts\"));\n        }), \"\\n        \", Spacebars.With(function() {\n          return Spacebars.call(Spacebars.dot(view.lookup(\"..\"), \"atts\", \"buttonContent\"));\n        }, function() {\n          return [ \"\\n        \", Blaze.View(function() {\n            return Spacebars.mustache(view.lookup(\".\"));\n          }), \"\\n        \" ];\n        }, function() {\n          return \"\\n        Submit\\n        \";\n        }), \"\\n      \"), \"\\n    \"), \"\\n    \" ];\n      }), \"\\n  \" ];\n    });\n  });\n}));\n","Template['quickForm_plain-fieldset'].helpers({\n  submitButtonAtts: function plfsQuickFormSubmitButtonAtts() {\n    var qfAtts = this.atts;\n    var atts = {type: \"submit\"};\n    if (typeof qfAtts.buttonClasses === \"string\") {\n      atts['class'] = qfAtts.buttonClasses;\n    }\n    return atts;\n  }\n});\n","\nTemplate.__checkName(\"afFieldLabel_plain-span\");\nTemplate[\"afFieldLabel_plain-span\"] = new Template(\"Template.afFieldLabel_plain-span\", (function() {\n  var view = this;\n  return HTML.SPAN(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), Blaze.View(function() {\n    return Spacebars.mustache(view.lookup(\"afFieldLabelText\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"atts\", \"name\")\n    }));\n  }));\n}));\n","/*\n * Template helpers for \"plain-span\" template\n */\n\nTemplate['afFieldLabel_plain-span'].helpers({\n  atts: function afFieldLabelAtts() {\n    var atts = (this || {}).atts;\n    return _.omit(atts, 'name', 'autoform', 'template');\n  }\n});\n","Utility = {\n  /**\n   * @method Utility.cleanNulls\n   * @private\n   * @param {Object} doc - Source object\n   * @returns {Object}\n   *\n   * Returns an object in which all properties with null, undefined, or empty\n   * string values have been removed, recursively.\n   */\n  cleanNulls: function cleanNulls(doc, isArray, keepEmptyStrings) {\n    var newDoc = isArray ? [] : {};\n    _.each(doc, function(val, key) {\n      if (!_.isArray(val) && isBasicObject(val)) {\n        val = cleanNulls(val, false, keepEmptyStrings); //recurse into plain objects\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (_.isArray(val)) {\n        val = cleanNulls(val, true, keepEmptyStrings); //recurse into non-typed arrays\n        if (!_.isEmpty(val)) {\n          newDoc[key] = val;\n        }\n      } else if (!Utility.isNullUndefinedOrEmptyString(val)) {\n        newDoc[key] = val;\n      } else if (keepEmptyStrings && typeof val === \"string\" && val.length === 0) {\n        newDoc[key] = val;\n      }\n    });\n    return newDoc;\n  },\n  /**\n   * @method Utility.reportNulls\n   * @private\n   * @param {Object} flatDoc - An object with no properties that are also objects.\n   * @returns {Object} An object in which the keys represent the keys in the\n   * original object that were null, undefined, or empty strings, and the value\n   * of each key is \"\".\n   */\n  reportNulls: function reportNulls(flatDoc, keepEmptyStrings) {\n    var nulls = {};\n    // Loop through the flat doc\n    _.each(flatDoc, function(val, key) {\n      // If value is undefined, null, or an empty string, report this as null so it will be unset\n      if (val === null) {\n        nulls[key] = \"\";\n      } else if (val === void 0) {\n        nulls[key] = \"\";\n      } else if (!keepEmptyStrings && typeof val === \"string\" && val.length === 0) {\n        nulls[key] = \"\";\n      }\n      // If value is an array in which all the values recursively are undefined, null, or an empty string, report this as null so it will be unset\n      else if (_.isArray(val) && Utility.cleanNulls(val, true, keepEmptyStrings).length === 0) {\n        nulls[key] = \"\";\n      }\n    });\n    return nulls;\n  },\n  /**\n   * @method Utility.docToModifier\n   * @private\n   * @param {Object} doc - An object to be converted into a MongoDB modifier\n   * @returns {Object} A MongoDB modifier.\n   *\n   * Converts an object into a modifier by flattening it, putting keys with\n   * null, undefined, and empty string values into `modifier.$unset`, and\n   * putting the rest of the keys into `modifier.$set`.\n   */\n  docToModifier: function docToModifier(doc, keepEmptyStrings) {\n    var modifier = {};\n\n    // Flatten doc\n    var mDoc = new MongoObject(doc);\n    var flatDoc = mDoc.getFlatObject({keepArrays: true});\n    mDoc = null;\n    // Get a list of null, undefined, and empty string values so we can unset them instead\n    var nulls = Utility.reportNulls(flatDoc, keepEmptyStrings);\n    flatDoc = Utility.cleanNulls(flatDoc, false, keepEmptyStrings);\n\n    if (!_.isEmpty(flatDoc)) {\n      modifier.$set = flatDoc;\n    }\n    if (!_.isEmpty(nulls)) {\n      modifier.$unset = nulls;\n    }\n    return modifier;\n  },\n  /**\n   * @method Utility.getSelectValues\n   * @private\n   * @param {Element} select - DOM Element from which to get current values\n   * @returns {string[]}\n   *\n   * Gets a string array of all the selected values in a given `select` DOM element.\n   */\n  getSelectValues: function getSelectValues(select) {\n    var result = [];\n    var options = select && select.options || [];\n    var opt;\n\n    for (var i = 0, ln = options.length; i < ln; i++) {\n      opt = options[i];\n\n      if (opt.selected) {\n        result.push(opt.value || opt.text);\n      }\n    }\n    return result;\n  },\n  /**\n   * @method Utility.maybeNum\n   * @private\n   * @param {string} val\n   * @returns {String|Number}\n   *\n   * If the given string can be converted to a number, returns the number.\n   * Otherwise returns the string.\n   */\n  maybeNum: function maybeNum(val) {\n    // Convert val to a number if possible; otherwise, just use the value\n    var floatVal = parseFloat(val);\n    if (!isNaN(floatVal)) {\n      return floatVal;\n    } else {\n      return val;\n    }\n  },\n  /**\n   * @method Utility.lookup\n   * @private\n   * @param {Any} obj\n   * @returns {Any}\n   *\n   * If `obj` is a string, returns the value of the property with that\n   * name on the `window` object. Otherwise returns `obj`.\n   */\n  lookup: function lookup(obj) {\n    var ref = window, arr;\n    if (typeof obj === \"string\") {\n      arr = obj.split(\".\");\n      while(arr.length && (ref = ref[arr.shift()]));\n      if (!ref) {\n        throw new Error(obj + \" is not in the window scope\");\n      }\n      return ref;\n    }\n    return obj;\n  },\n  /**\n   * @method Utility.getDefs\n   * @private\n   * @param {SimpleSchema} ss\n   * @param {String} name\n   * @return {Object} Schema definitions object\n   *\n   * Returns the schema definitions object from a SimpleSchema instance. Equivalent to calling\n   * `ss.schema(name)` but handles throwing errors if `name` is not a string or is not a valid\n   * field name for this SimpleSchema instance.\n   */\n  getDefs: function getDefs(ss, name) {\n    if (typeof name !== \"string\") {\n      throw new Error(\"Invalid field name: (not a string)\");\n    }\n\n    var defs = ss.schema(name);\n    if (!defs)\n      throw new Error(\"Invalid field name: \" + name);\n    return defs;\n  },\n  /**\n   * @method Utility.objAffectsKey\n   * @private\n   * @param  {Object} obj\n   * @param  {String} key\n   * @return {Boolean}\n   * @todo should make this a static method in MongoObject\n   */\n  objAffectsKey: function objAffectsKey(obj, key) {\n    var mDoc = new MongoObject(obj);\n    return mDoc.affectsKey(key);\n  },\n  /**\n   * @method Utility.expandObj\n   * @private\n   * @param  {Object} doc\n   * @return {Object}\n   *\n   * Takes a flat object and returns an expanded version of it.\n   */\n  expandObj: function expandObj(doc) {\n    var newDoc = {}, subkeys, subkey, subkeylen, nextPiece, current;\n    _.each(doc, function(val, key) {\n      subkeys = key.split(\".\");\n      subkeylen = subkeys.length;\n      current = newDoc;\n      for (var i = 0; i < subkeylen; i++) {\n        subkey = subkeys[i];\n        if (typeof current[subkey] !== \"undefined\" && !_.isObject(current[subkey])) {\n          break; //already set for some reason; leave it alone\n        }\n        if (i === subkeylen - 1) {\n          //last iteration; time to set the value\n          current[subkey] = val;\n        } else {\n          //see if the next piece is a number\n          nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n          if (isNaN(nextPiece) && !_.isObject(current[subkey])) {\n            current[subkey] = {};\n          } else if (!isNaN(nextPiece) && !_.isArray(current[subkey])) {\n            current[subkey] = [];\n          }\n        }\n        current = current[subkey];\n      }\n    });\n    return newDoc;\n  },\n  /**\n   * @method Utility.compactArrays\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference, compacting any arrays at any level recursively.\n   */\n  compactArrays: function compactArrays(obj) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          obj[key] = _.without(val, void 0, null);\n          _.each(obj[key], function (arrayItem) {\n            compactArrays(arrayItem);\n          });\n        } else if (!(val instanceof Date) && _.isObject(val)) {\n          //recurse into objects\n          compactArrays(val);\n        }\n      });\n    }\n  },\n  /**\n   * @method Utility.bubbleEmpty\n   * @private\n   * @param  {Object} obj\n   * @return {undefined}\n   *\n   * Edits the object by reference.\n   */\n  bubbleEmpty: function bubbleEmpty(obj, keepEmptyStrings) {\n    if (_.isObject(obj)) {\n      _.each(obj, function (val, key) {\n        if (_.isArray(val)) {\n          _.each(val, function (arrayItem) {\n            bubbleEmpty(arrayItem);\n          });\n        } else if (isBasicObject(val)) {\n          var allEmpty = _.all(val, function (prop) {\n            return (prop === void 0 || prop === null || (!keepEmptyStrings && typeof prop === \"string\" && prop.length === 0));\n          });\n          if (_.isEmpty(val) || allEmpty) {\n            obj[key] = null;\n          } else {\n            //recurse into objects\n            bubbleEmpty(val);\n          }\n        }\n      });\n    }\n  },\n  /**\n   * @method Utility.getSimpleSchemaFromContext\n   * @private\n   * @param  {Object} context\n   * @return {SimpleSchema}\n   *\n   * Given a context object that may or may not have schema and collection properties,\n   * returns a SimpleSchema instance or throws an error if one cannot be obtained.\n   */\n  getSimpleSchemaFromContext: function getSimpleSchemaFromContext(context, formId) {\n    // If schema attribute, use that\n    var ss = Utility.lookup(context.schema);\n    if (ss) {\n      if (ss instanceof SimpleSchema) {\n        return ss;\n      } else {\n        throw new Error('AutoForm: schema attribute for form with id \"' + formId + '\" is not a SimpleSchema instance');\n      }\n    }\n    // If no schema attribute, use the schema attached to the collection\n    var collection = Utility.lookup(context.collection);\n    if (collection) {\n      if (typeof collection.simpleSchema === 'function') {\n        return collection.simpleSchema();\n      } else {\n        throw new Error('AutoForm: collection attribute for form with id \"' + formId + '\" refers to a collection that does not have a schema, or is not a collection. You might have forgotten to attach a schema to the collection or you might need to add the collection2 package to your app.');\n      }\n    }\n    // If we got this far, we have no schema so throw an error\n    throw new Error('AutoForm: form with id \"' + formId + '\" needs either \"schema\" or \"collection\" attribute');\n  },\n  /**\n   * @method Utility.isNullUndefinedOrEmptyString\n   * @private\n   * @param  {Any} val\n   * @return {Boolean}\n   *\n   * Returns `true` if the value is null, undefined, or an empty string\n   */\n  isNullUndefinedOrEmptyString: function isNullUndefinedOrEmptyString(val) {\n    return (val === void 0 || val === null || (typeof val === \"string\" && val.length === 0));\n  },\n  /**\n   * @method Utility.isValidDateString\n   * @private\n   * @param  {String}  dateString\n   * @return {Boolean}\n   *\n   * Returns `true` if dateString is a \"valid date string\"\n   */\n  isValidDateString: function isValidDateString(dateString) {\n    var m = moment(dateString, 'YYYY-MM-DD', true);\n    return m && m.isValid();\n  },\n  /**\n   * @method Utility.isValidTimeString\n   * @private\n   * @param  {String}  timeString\n   * @return {Boolean}\n   *\n   * Returns `true` if timeString is a \"valid time string\"\n   */\n  isValidTimeString: function isValidTimeString(timeString) {\n    if (typeof timeString !== \"string\")\n      return false;\n\n    //this reg ex actually allows a few invalid hours/minutes/seconds, but\n    //we can catch that when parsing\n    var regEx = /^[0-2][0-9]:[0-5][0-9](:[0-5][0-9](\\.[0-9]{1,3})?)?$/;\n    return regEx.test(timeString);\n  },\n  /**\n   * @method  Utility.dateToDateString\n   * @private\n   * @param  {Date} date\n   * @return {String}\n   *\n   * Returns a \"valid date string\" representing the local date.\n   */\n  dateToDateString: function dateToDateString(date) {\n    var m = (date.getMonth() + 1);\n    if (m < 10) {\n      m = \"0\" + m;\n    }\n    var d = date.getDate();\n    if (d < 10) {\n      d = \"0\" + d;\n    }\n    return date.getFullYear() + '-' + m + '-' + d;\n  },\n  /**\n   * @method  Utility.dateToDateStringUTC\n   * @private\n   * @param  {Date} date\n   * @return {String}\n   *\n   * Returns a \"valid date string\" representing the date converted to the UTC time zone.\n   */\n  dateToDateStringUTC: function dateToDateStringUTC(date) {\n    var m = (date.getUTCMonth() + 1);\n    if (m < 10) {\n      m = \"0\" + m;\n    }\n    var d = date.getUTCDate();\n    if (d < 10) {\n      d = \"0\" + d;\n    }\n    return date.getUTCFullYear() + '-' + m + '-' + d;\n  },\n  /**\n   * @method  Utility.dateToNormalizedForcedUtcGlobalDateAndTimeString\n   * @private\n   * @param  {Date} date\n   * @return {String}\n   *\n   * Returns a \"valid normalized forced-UTC global date and time string\" representing the time\n   * converted to the UTC time zone and expressed as the shortest possible string for the given\n   * time (e.g. omitting the seconds component entirely if the given time is zero seconds past the minute).\n   *\n   * http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#date-and-time-state-(type=datetime)\n   * http://www.whatwg.org/specs/web-apps/current-work/multipage/common-microsyntaxes.html#valid-normalized-forced-utc-global-date-and-time-string\n   */\n  dateToNormalizedForcedUtcGlobalDateAndTimeString: function dateToNormalizedForcedUtcGlobalDateAndTimeString(date) {\n    return moment(date).utc().format(\"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\");\n  },\n  /**\n   * @method  Utility.isValidNormalizedForcedUtcGlobalDateAndTimeString\n   * @private\n   * @param  {String} dateString\n   * @return {Boolean}\n   *\n   * Returns true if dateString is a \"valid normalized forced-UTC global date and time string\"\n   */\n  isValidNormalizedForcedUtcGlobalDateAndTimeString: function isValidNormalizedForcedUtcGlobalDateAndTimeString(dateString) {\n    if (typeof dateString !== \"string\")\n      return false;\n\n    var datePart = dateString.substring(0, 10);\n    var tPart = dateString.substring(10, 11);\n    var timePart = dateString.substring(11, dateString.length - 1);\n    var zPart = dateString.substring(dateString.length - 1);\n    return Utility.isValidDateString(datePart) && tPart === \"T\" && Utility.isValidTimeString(timePart) && zPart === \"Z\";\n  },\n  /**\n   * @method Utility.dateToNormalizedLocalDateAndTimeString\n   * @private\n   * @param {Date} date The Date object\n   * @param {String} [timezoneId] A valid timezoneId that moment-timezone understands, e.g., \"America/Los_Angeles\"\n   * @return {String}\n   *\n   * Returns a \"valid normalized local date and time string\".\n   */\n  dateToNormalizedLocalDateAndTimeString: function dateToNormalizedLocalDateAndTimeString(date, timezoneId) {\n    var m = moment(date);\n    // by default, we assume local timezone; add moment-timezone to app and pass timezoneId\n    // to use a different timezone\n    if (typeof timezoneId === \"string\") {\n      if (typeof m.tz !== \"function\") {\n        throw new Error(\"If you specify a timezoneId, make sure that you've added a moment-timezone package to your app\");\n      }\n      m.tz(timezoneId);\n    }\n    return m.format(\"YYYY-MM-DD[T]HH:mm:ss.SSS\");\n  },\n  /**\n   * @method  Utility.isValidNormalizedLocalDateAndTimeString\n   * @private\n   * @param  {String} dtString\n   * @return {Boolean}\n   *\n   * Returns true if dtString is a \"valid normalized local date and time string\"\n   */\n  isValidNormalizedLocalDateAndTimeString: function isValidNormalizedLocalDateAndTimeString(dtString) {\n    if (typeof dtString !== \"string\")\n      return false;\n\n    var datePart = dtString.substring(0, 10);\n    var tPart = dtString.substring(10, 11);\n    var timePart = dtString.substring(11, dtString.length);\n    return Utility.isValidDateString(datePart) && tPart === \"T\" && Utility.isValidTimeString(timePart);\n  },\n  /**\n   * @method Utility.normalizeContext\n   * @private\n   * @param  {Object} context A context object, potentially with an `atts` or `autoform` property.\n   * @param {String} name The name of the helper or component we're calling from, for in a potential error message.\n   * @return {Object} Normalized context object\n   *\n   * Returns an object with `afc`, `af`, and `atts` properties, normalized from whatever object is passed in.\n   * This helps deal with the fact that we have to pass the ancestor autoform's context to different\n   * helpers and components in different ways, but in all cases we want to get access to it and throw\n   * an error if we can't find an autoform context.\n   */\n  normalizeContext: function autoFormNormalizeContext(context, name) {\n    context = context || {};\n    var atts = context.atts || context;\n    var autoform = AutoForm.find(name);\n    var defs = Utility.getDefs(autoform.ss, atts.name); //defs will not be undefined\n\n    // For array fields, `allowedValues` is on the array item definition\n    if (defs.type === Array) {\n      var itemDefs = Utility.getDefs(autoform.ss, atts.name + \".$\");\n      var allowedValues = itemDefs.allowedValues;\n    } else {\n      var allowedValues = defs.allowedValues;\n    }\n\n    var defaultAttributes = defs.autoform || {};\n\n    // This is where we add default attributes specified in\n    // defs.autoform. We don't add them for afFieldLabel.\n    if (name === \"afFieldLabel\") {\n      if (_.has(atts, \"options\")) {\n        delete atts.options;\n      }\n    } else {\n      // If options=\"auto\", we want to use defs.autoform.options\n      // if specified and otherwise fall back to \"allowed\"\n      if (defaultAttributes.options && atts.options === \"auto\")\n        delete atts.options;\n      // \"autoform\" option in the schema provides default atts\n      atts = _.extend({}, defaultAttributes, atts);\n      // If still set to \"auto\", then there were no options in defs, so we use \"allowed\"\n      if (atts.options === \"auto\") {\n        if (allowedValues) {\n          atts.options = \"allowed\";\n        } else {\n          delete atts.options;\n        }\n      }\n    }\n\n    return {\n      af: autoform,\n      atts: atts,\n      defs: defs\n    };\n  },\n  /**\n   * @method Utility.stringToArray\n   * @private\n   * @param {String|Array} A variable that might be a string or an array.\n   * @return {Array} The array, building it from a comma-delimited string if necessary.\n   */\n  stringToArray: function stringToArray(s, errorMessage) {\n    if (typeof s === \"string\") {\n      return s.replace(/ /g, '').split(',');\n    } else if (!_.isArray(s)) {\n      throw new Error(errorMessage);\n    } else {\n      return s;\n    }\n  }\n};\n\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== \"function\") {\n  if (typeof \"\".__proto__ === \"object\") {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n\n/* Tests whether \"obj\" is an Object as opposed to\n * something that inherits from Object\n *\n * @param {any} obj\n * @returns {Boolean}\n */\nvar isBasicObject = function(obj) {\n  return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n","/**\n * @constructor\n * @private\n * @param {String} migrationName\n *\n * Internal helper object to preserve form inputs across Hot Code Push\n * and across \"pages\" navigation if the option is enabled.\n */\nFormPreserve = function formPreserveConstructor(migrationName) {\n  var self = this;\n  if (! _.isString(migrationName))\n    throw Error(\"You must define an unique migration name of type String\");\n  self.registeredForms = {};\n  self.retrievedDocuments = {};\n  if (Package.reload) {\n    var Reload = Package.reload.Reload;\n    self.retrievedDocuments = Reload._migrationData(migrationName) || {};\n    Reload._onMigrate(migrationName, function () {\n      return [true, self._retrieveRegisteredDocuments()];\n    });\n  }\n};\n\nFormPreserve.prototype.getDocument = function (formId) {\n  var self = this;\n  if (! _.has(self.retrievedDocuments, formId))\n    return false;\n  else\n    return self.retrievedDocuments[formId];\n};\n\nFormPreserve.prototype.registerForm = function (formId, retrieveFunc) {\n  this.registeredForms[formId] = retrieveFunc;\n};\n\nFormPreserve.prototype.unregisterForm = function (formId) {\n  delete this.registeredForms[formId];\n  delete this.retrievedDocuments[formId];\n};\n\nFormPreserve.prototype.unregisterAllForms = function () {\n  var self = this;\n  self.registeredForms = {};\n  self.retrievedDocuments = {};\n};\n\nFormPreserve.prototype._retrieveRegisteredDocuments = function () {\n  var self = this;\n  res = {};\n  _.each(self.registeredForms, function (retrieveFunc, formId) {\n    res[formId] = retrieveFunc();\n  });\n  return res;\n};\n","// Manages all hooks, supporting append/replace, get\n\nHooks = {\n  form: {},\n  global: {\n    before: {},\n    after: {},\n    formToDoc: [],\n    docToForm: [],\n    onSubmit: [],\n    onSuccess: [],\n    onError: [],\n    beginSubmit: [],\n    endSubmit: []\n  }\n};\n\nHooks.addHooksToList = function addHooksToList(hooksList, hooks, replace) {\n  // Add before hooks\n  hooks.before && _.each(hooks.before, function autoFormBeforeHooksEach(func, type) {\n    if (typeof func !== \"function\") {\n      throw new Error(\"AutoForm before hook must be a function, not \" + typeof func);\n    }\n    hooksList.before[type] = (!replace && hooksList.before[type]) ? hooksList.before[type] : [];\n    hooksList.before[type].push(func);\n  });\n\n  // Add after hooks\n  hooks.after && _.each(hooks.after, function autoFormAfterHooksEach(func, type) {\n    if (typeof func !== \"function\") {\n      throw new Error(\"AutoForm after hook must be a function, not \" + typeof func);\n    }\n    hooksList.after[type] = (!replace && hooksList.after[type]) ? hooksList.after[type] : [];\n    hooksList.after[type].push(func);\n  });\n\n  // Add all other hooks\n  _.each(['formToDoc', 'docToForm', 'onSubmit', 'onSuccess', 'onError', 'beginSubmit', 'endSubmit'], function autoFormHooksEach(name) {\n    if (hooks[name]) {\n      if (typeof hooks[name] !== \"function\") {\n        throw new Error(\"AutoForm \" + name + \" hook must be a function, not \" + typeof hooks[name]);\n      }\n\n      if(replace) {\n          hooksList[name] = [];\n      }\n\n      hooksList[name].push(hooks[name]);\n    }\n  });\n};\n\nHooks.getHooks = function getHooks(formId, type, subtype) {\n  var f, g;\n  if (subtype) {\n    f = Hooks.form[formId] && Hooks.form[formId][type] && Hooks.form[formId][type][subtype] || [];\n    g = Hooks.global[type] && Hooks.global[type][subtype] || [];\n  } else {\n    f = Hooks.form[formId] && Hooks.form[formId][type] || [];\n    g = Hooks.global[type] || [];\n  }\n  return f.concat(g);\n};\n","// Default Handlers\ndefaultInputValueHandlers = {\n\t'select.autoform-boolean': function () {\n\t\tvar val = this.val();\n\t\tif (val === \"true\") {\n\t\t\treturn true;\n\t\t} else if (val === \"false\") {\n\t\t\treturn false;\n\t\t} \n\t},\n\t'select[multiple]': function () {\n\t\treturn Utility.getSelectValues(this[0]);\n\t},\n\t'select': function () {\n\t\treturn this.val();\n\t},\n\t'input.autoform-boolean[type=checkbox]': function () {\n\t\t// boolean checkbox\n\t\treturn this.is(\":checked\");\n\t},\n\t'input.autoform-array-item[type=checkbox]': function () {\n\t\t// array checkbox\n\t\tif (this.is(\":checked\")) {\n\t\t\treturn this.val();\n\t\t}\n\t},\n\t'input.autoform-boolean[type=radio]': function () {\n\t\t//boolean radio\n\t\tvar val = this.val();\n\t\tif (this.is(\":checked\")) {\n\t\t\tif (val === \"true\") {\n\t        \treturn true;\n\t        } else if (val === \"false\") {\n\t         \treturn false;\n\t        }\n\t\t}\n\t},\n\t'input[type=radio]': function () {\n\t\tif (this.is(\":checked\")) {\n\t\t\treturn this.val();\n\t\t}\n\t},\n\t'input.autoform-boolean[type=hidden]': function () {\n\t\t// type overridden to hidden, but schema expects boolean\n\t\tvar val = this.val();\n\t\tif (val === \"true\") {\n\t\t\treturn true;\n\t\t} else if (val === \"false\") {\n\t\t\treturn false;\n\t\t}\n\t},\n\t'[type=select]': function () {\n\t\treturn Utility.maybeNum(this.val());\n\t},\n\t'input[type=date]': function () {\n\t\tvar val = this.val();\n\t\tif (Utility.isValidDateString(val)) {\n\t\t\t//Date constructor will interpret val as UTC and create\n\t\t\t//date at mignight in the morning of val date in UTC time zone\n\t\t\treturn new Date(val);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\t'input[type=datetime]': function () {\n\t\tvar val = this.val();\n\t\tval = (typeof val === \"string\") ? val.replace(/ /g, \"T\") : val;\n\t\tif (Utility.isValidNormalizedForcedUtcGlobalDateAndTimeString(val)) {\n\t\t\t//Date constructor will interpret val as UTC due to ending \"Z\"\n\t\t\treturn new Date(val);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\t'input[type=datetime-local]': function () {\n\t\tvar val = this.val();\n\t\tval = (typeof val === \"string\") ? val.replace(/ /g, \"T\") : val;\n\t\tif (Utility.isValidNormalizedLocalDateAndTimeString(val)) {\n\t\t\tvar timezoneId = this.attr(\"data-timezone-id\");\n\t\t\t// default is local, but if there's a timezoneId, we use that\n\t\t\tif (typeof timezoneId === \"string\") {\n\t\t\t\tif (typeof moment.tz !== \"function\") {\n\t        throw new Error(\"If you specify a timezoneId, make sure that you've added a moment-timezone package to your app\");\n\t      }\n\t      return moment.tz(val, timezoneId).toDate();\n\t\t\t} else {\n\t\t\t\treturn moment(val).toDate();\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\t'[contenteditable]': function () {\n\t\treturn this.html();\n\t},\n\t'[data-null-value]': function () {\n\t\treturn null;\n\t},\n\t'[data-schema-key]': function () {\n\t\t// fallback\n\t\treturn this.val();\n\t}\n};\n\n// must be used in a template helper\nexpectsArray = function expectsArray(inputAtts) {\n\t// If the user overrides the type to anything,\n  // then we won't be using a select box and\n  // we won't be expecting an array for the current value.\n  // This logic should probably be more robust. The idea is that\n  // the user should be able to specify any type of control to use\n  // to override the default logic, and then she can use either a custom input\n  // handler or formToDoc hook to change the value into the expected array.\n\treturn (AutoForm.getSchemaForField(inputAtts.name).type === Array && !inputAtts.type);\n};\n\n// Determines based on different options what type of input/control should be used\ngetInputType = function getInputType(atts) {\n\t// Does the schema/form expect the value of the field to be an array?\n\tvar expectsArray = AutoForm.expectsArray(atts);\n\n\t// What is the `type` in the schema definition?\n\tvar defs = AutoForm.getSchemaForField(atts.name);\n  var schemaType = defs.type;\n  if (schemaType === Array) {\n    schemaType = AutoForm.find().ss.schema(atts.name + \".$\");\n  }\n\n  // Based on the `type` attribute, the `type` from the schema, and/or\n  // other characteristics such as regEx and whether an array is expected,\n  // choose which type string to return.\n  // TODO allow outside packages to extend/override this logic.\n  var type = \"text\";\n  if (atts.type) {\n    type = atts.type;\n  } else if (atts.options) {\n    if (atts.noselect) {\n      if (expectsArray) {\n        type = \"select-checkbox\";\n      } else {\n        type = \"select-radio\";\n      }\n    } else {\n      type = \"select\";\n    }\n  } else if (schemaType === String && defs.regEx === SimpleSchema.RegEx.Email) {\n    type = \"email\";\n  } else if (schemaType === String && defs.regEx === SimpleSchema.RegEx.Url) {\n    type = \"url\";\n  } else if (schemaType === String && atts.rows) {\n    type = \"textarea\";\n  } else if (schemaType === Number) {\n    type = \"number\";\n  } else if (schemaType === Date) {\n    type = \"date\";\n  } else if (schemaType === Boolean) {\n    if (atts.radio) {\n      type = \"boolean-radios\";\n    } else if (atts.select) {\n      type = \"boolean-select\";\n    } else {\n      type = \"boolean-checkbox\";\n    }\n  }\n  return type;\n};","// Tracks form data; particularly needed to track the number of items in arrays in the doc\n\nFormData = function afFormData() {\n\tvar self = this;\n\tself.forms = {};\n};\n\nFormData.prototype.initForm = function fdInitForm(formId) {\n\tvar self = this;\n\n\tif (self.forms[formId])\n\t\treturn;\n\n\tself.forms[formId] = {\n\t\tsourceDoc: null,\n\t\tdeps: {\n\t\t\tsourceDoc: new Deps.Dependency\n\t\t}\n\t};\n};\n\nFormData.prototype.sourceDoc = function fdSourceDoc(formId, sourceDoc) {\n\tvar self = this;\n\tself.initForm(formId);\n\n\tif (sourceDoc) {\n\t\t//setter\n\t\tself.forms[formId].sourceDoc = sourceDoc;\n\t\tself.forms[formId].deps.sourceDoc.changed();\n\t} else {\n\t\t//getter\n\t\tself.forms[formId].deps.sourceDoc.depend();\n\t\treturn self.forms[formId].sourceDoc;\n\t}\n};\n\nFormData.prototype.getDocCountForField = function fdGetDocCountForField(formId, field) {\n\tvar self = this;\n\tvar mDoc = self.sourceDoc(formId);\n\tvar docCount;\n\tif (mDoc) {\n\t\tvar keyInfo = mDoc.getInfoForKey(field);\n\t\tif (keyInfo && _.isArray(keyInfo.value)) {\n\t\t\tdocCount = keyInfo.value.length\n\t\t}\n\t}\n\treturn docCount;\n};","// Track arrays; this allows us to add/remove fields or groups of fields for an array\n// but still easily respect minCount and maxCount, and properly add/remove the same\n// items from the database once the form is submitted.\n\nArrayTracker = function afArrayTracker() {\n  var self = this;\n  self.info = {};\n};\n\nArrayTracker.prototype.getMinMax = function atGetMinMax(ss, field, overrideMinCount, overrideMaxCount) {\n  var defs = Utility.getDefs(ss, field);\n\n  // minCount is set by the schema, but can be set higher on the field attribute\n  overrideMinCount = overrideMinCount || 0;\n  var minCount = defs.minCount || 0;\n  minCount = Math.max(overrideMinCount, minCount);\n\n  // maxCount is set by the schema, but can be set lower on the field attribute\n  overrideMaxCount = overrideMaxCount || Infinity;\n  var maxCount = defs.maxCount || Infinity;\n  maxCount = Math.min(overrideMaxCount, maxCount);\n\n  return {minCount: minCount, maxCount: maxCount};\n};\n\nArrayTracker.prototype.initForm = function atInitForm(formId) {\n\tvar self = this;\n\n\tif (self.info[formId])\n\t\treturn;\n\n\tself.info[formId] = {};\n};\n\nArrayTracker.prototype.getForm = function atInitForm(formId) {\n\tvar self = this;\n\tself.initForm(formId);\n\treturn self.info[formId];\n};\n\nArrayTracker.prototype.ensureField = function atEnsureField(formId, field) {\n\tvar self = this;\n\tself.initForm(formId);\n\n\tif (!self.info[formId][field]) {\n\t\tself.resetField(formId, field);\n\t}\n};\n\nArrayTracker.prototype.initField = function atInitField(formId, field, ss, docCount, overrideMinCount, overrideMaxCount) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\n\tif (self.info[formId][field].array != null)\n\t\treturn;\n\n\t// If we have a doc: The count should be the maximum of docCount or schema minCount or field minCount or 1.\n\t// If we don't have a doc: The count should be the maximum of schema minCount or field minCount or 1.\n\tvar range = self.getMinMax(ss, field, overrideMinCount, overrideMaxCount);\n\tvar arrayCount = Math.max(range.minCount, (docCount == null) ? 1 : docCount);\n\n\t// If this is an array of objects, collect names of object props\n\tvar childKeys = [];\n\tif (ss.schema(field + '.$').type === Object) {\n    childKeys = ss.objectKeys(SimpleSchema._makeGeneric(field) + '.$');\n\t}\n\n\tvar loopArray = [];\n\tfor (var i = 0; i < arrayCount; i++) {\n\t\tvar loopCtx = createLoopCtx(formId, field, i, childKeys, overrideMinCount, overrideMaxCount);\n\t\tloopArray.push(loopCtx);\n\t};\n\n\tself.info[formId][field].array = loopArray;\n\tvar count = loopArray.length;\n\tself.info[formId][field].count = count;\n\tself.info[formId][field].visibleCount = count;\n\tself.info[formId][field].deps.changed();\n};\n\nArrayTracker.prototype.resetField = function atResetField(formId, field) {\n\tvar self = this;\n\tself.initForm(formId);\n\n\tif (!self.info[formId][field]) {\n\t\tself.info[formId][field] = {\n\t\t\tdeps: new Deps.Dependency\n\t\t};\n\t}\n\n\tself.info[formId][field].array = null;\n\tself.info[formId][field].count = 0;\n\tself.info[formId][field].visibleCount = 0;\n\tself.info[formId][field].deps.changed();\n};\n\nArrayTracker.prototype.resetForm = function atResetForm(formId) {\n\tvar self = this;\n\t_.each(self.info[formId], function (info, field) {\n\t\tself.resetField(formId, field);\n\t});\n};\n\nArrayTracker.prototype.untrackForm = function atUntrackForm(formId) {\n\tvar self = this;\n\tself.info[formId] = {};\n};\n\nArrayTracker.prototype.tracksField = function atTracksField(formId, field) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\tself.info[formId][field].deps.depend();\n\treturn !!self.info[formId][field].array;\n};\n\nArrayTracker.prototype.getField = function atGetField(formId, field) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\tself.info[formId][field].deps.depend();\n\treturn self.info[formId][field].array;\n};\n\nArrayTracker.prototype.getCount = function atGetCount(formId, field) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\tself.info[formId][field].deps.depend();\n\treturn self.info[formId][field].count;\n};\n\nArrayTracker.prototype.getVisibleCount = function atGetVisibleCount(formId, field) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\tself.info[formId][field].deps.depend();\n\treturn self.info[formId][field].visibleCount;\n};\n\nArrayTracker.prototype.isFirstFieldlVisible = function atIsFirstFieldlVisible(formId, field, currentIndex) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\tself.info[formId][field].deps.depend();\n\tvar firstVisibleField = _.find(self.info[formId][field].array, function(currentField) {\n\t\treturn !currentField.removed;\n\t});\n\treturn (firstVisibleField && firstVisibleField.index === currentIndex);\n};\n\nArrayTracker.prototype.isLastFieldlVisible = function atIsLastFieldlVisible(formId, field, currentIndex) {\n\tvar self = this;\n\tself.ensureField(formId, field);\n\tself.info[formId][field].deps.depend();\n\tvar lastVisibleField = _.last(_.filter(self.info[formId][field].array, function(currentField) {\n\t\treturn !currentField.removed;\n\t}));\n\treturn (lastVisibleField && lastVisibleField.index === currentIndex);\n};\n\nArrayTracker.prototype.addOneToField = function atAddOneToField(formId, field, ss, overrideMinCount, overrideMaxCount) {\n  var self = this;\n  self.ensureField(formId, field);\n\n  if (!self.info[formId][field].array) {\n  \treturn;\n  }\n\n  var currentCount = self.info[formId][field].visibleCount\n  var maxCount = self.getMinMax(ss, field, overrideMinCount, overrideMaxCount).maxCount;\n\n  if (currentCount < maxCount) {\n\t  var i = self.info[formId][field].array.length;\n\n\t  // If this is an array of objects, collect names of object props\n\t  var childKeys = [];\n\t  if (ss.schema(field + '.$').type === Object) {\n      childKeys = ss.objectKeys(SimpleSchema._makeGeneric(field) + '.$');\n\t  }\n\n\t  var loopCtx = createLoopCtx(formId, field, i, childKeys, overrideMinCount, overrideMaxCount);\n\n\t  self.info[formId][field].array.push(loopCtx);\n\t  self.info[formId][field].count++;\n\t  self.info[formId][field].visibleCount++;\n\t  self.info[formId][field].deps.changed();\n  }\n};\n\nArrayTracker.prototype.removeFromFieldAtIndex = function atRemoveFromFieldAtIndex(formId, field, index, ss, overrideMinCount, overrideMaxCount) {\n  var self = this;\n  self.ensureField(formId, field);\n\n  if (!self.info[formId][field].array) {\n  \treturn;\n  }\n\n  var currentCount = self.info[formId][field].visibleCount\n  var minCount = self.getMinMax(ss, field, overrideMinCount, overrideMaxCount).minCount;\n\n  if (currentCount > minCount) {\n    self.info[formId][field].array[index].removed = true;\n    self.info[formId][field].count--;\n    self.info[formId][field].visibleCount--;\n    self.info[formId][field].deps.changed();\n  }\n}\n\n/*\n * PRIVATE\n */\nvar createLoopCtx = function(formId, field, index, childKeys, overrideMinCount, overrideMaxCount) {\n  var loopCtx = {\n  \tformId:         formId,\n  \tarrayFieldName: field, \n  \tname:           field + '.' + index,\n  \tindex:          index, \n  \tminCount:       overrideMinCount,\n  \tmaxCount:       overrideMaxCount\n  };\n\n  // If this is an array of objects, add child key names under loopCtx.current[childName] = fullKeyName\n  if (childKeys.length) {\n    loopCtx.current = {};\n\t_.each(childKeys, function (k) {\n\t  loopCtx.current[k] = field + '.' + index + '.' + k;\n    });\n  }\n\n  return loopCtx;\n}","defaultFormId = \"_afGenericID\";\nformPreserve = new FormPreserve(\"autoforms\");\nformData = {}; //for looking up autoform data by form ID\ntemplatesById = {}; //keep a reference of autoForm templates by form `id` for AutoForm.getFormValues\nformValues = {}; //for reactive show/hide based on current value of a field\nformDeps = {}; //for invalidating the form inner context and causing rerender\nfd = new FormData();\narrayTracker = new ArrayTracker();\ncustomInputValueHandlers = {};\ndefaultTemplate = \"bootstrap3\";\n// All use global template by default\ndefaultTypeTemplates = {\n  quickForm: null,\n  afFieldLabel: null,\n  afFieldSelect: null,\n  afCheckboxGroup: null,\n  afRadioGroup: null,\n  afSelect: null,\n  afTextarea: null,\n  afContenteditable: null,\n  afCheckbox: null,\n  afRadio: null,\n  afInput: null,\n  afFormGroup: null,\n  afObjectField: null,\n  afArrayField: null\n};\n\ndeps = {\n  defaultTemplate: new Deps.Dependency,\n  defaultTypeTemplates: {\n    quickForm: new Deps.Dependency,\n    afFieldLabel: new Deps.Dependency,\n    afFieldSelect: new Deps.Dependency,\n    afCheckboxGroup: new Deps.Dependency,\n    afRadioGroup: new Deps.Dependency,\n    afSelect: new Deps.Dependency,\n    afTextarea: new Deps.Dependency,\n    afContenteditable: new Deps.Dependency,\n    afCheckbox: new Deps.Dependency,\n    afRadio: new Deps.Dependency,\n    afInput: new Deps.Dependency,\n    afFormGroup: new Deps.Dependency,\n    afObjectField: new Deps.Dependency,\n    afArrayField: new Deps.Dependency\n  }\n};\n\n/*\n * Private Helper Functions\n */\n\nfunction getFieldsValues(fields) {\n  var doc = {};\n  fields.each(function formValuesEach() {\n    var field = $(this);\n    var fieldName = field.attr(\"data-schema-key\");\n\n    // use custom handlers first, and then use built-in handlers\n    _.every([customInputValueHandlers, defaultInputValueHandlers], function (handlerList) {\n      return _.every(handlerList, function (handler, selector) {\n        if (field.filter(selector).length === 1) {\n          // Special handling for checkboxes that create arrays\n          // XXX maybe there is a way to do this better\n          var isArrayCheckBox = (field.hasClass(\"autoform-array-item\"));\n          if (isArrayCheckBox) {\n            // Add empty array no matter what,\n            // to ensure that unchecking all boxes\n            // will empty the array.\n            if (!_.isArray(doc[fieldName])) {\n              doc[fieldName] = [];\n            }\n          }\n          var val = handler.call(field);\n          if (val !== void 0) {\n            if (isArrayCheckBox) {\n              doc[fieldName].push(val);\n            } else {\n              doc[fieldName] = val;\n            }\n          }\n          return false;\n        }\n        return true;\n      });\n    });\n  });\n\n  return doc;\n}\n\ngetFieldValue = function getFieldValue(template, key) {\n  var doc = getFieldsValues(template.$('[data-schema-key=\"' + key + '\"], [data-schema-key^=\"' + key + '.\"]'));\n  return doc && doc[key];\n};\n\ngetFormValues = function getFormValues(template, formId, ss) {\n  var formInfo = formData[formId];\n  // By default, we do not keep empty strings\n  var keepEmptyStrings = false;\n  if (formInfo.removeEmptyStrings === false) {\n    keepEmptyStrings = true;\n  }\n  // By default, we do filter\n  var filter = true;\n  if (formInfo.filter === false) {\n    filter = false;\n  }\n  // By default, we do autoConvert\n  var autoConvert = true;\n  if (formInfo.autoConvert === false) {\n    autoConvert = false;\n  }\n  // By default, we do trimStrings\n  var trimStrings = true;\n  if (formInfo.trimStrings === false) {\n    trimStrings = false;\n  }\n\n  // Build doc from field values\n  var doc = getFieldsValues(template.$(\"[data-schema-key]\").not(\"[disabled]\"));\n\n  // Expand the object\n  doc = Utility.expandObj(doc);\n\n  // As array items are removed, gaps can appear in the numbering,\n  // which results in arrays that have undefined items. Here we\n  // remove any array items that are undefined.\n  Utility.compactArrays(doc);\n\n  // When all fields that comprise a sub-object are empty, we should unset\n  // the whole subobject and not complain about required fields in it. For example,\n  // if `profile.address` has several properties but they are all null or undefined,\n  // we will set `profile.address=null`. This ensures that we don't get incorrect validation\n  // errors about required fields that are children of optional objects.\n  Utility.bubbleEmpty(doc, keepEmptyStrings);\n\n  // Pass expanded doc through formToDoc hooks\n  var hookCtx = {\n    template: template,\n    formId: formId\n  };\n  var transforms = Hooks.getHooks(formId, 'formToDoc');\n  _.each(transforms, function formValuesTransform(transform) {\n    doc = transform.call(hookCtx, doc, ss, formId);\n  });\n\n  // We return doc, insertDoc, and updateDoc.\n  // For insertDoc, delete any properties that are null, undefined, or empty strings.\n  // For updateDoc, convert to modifier object with $set and $unset.\n  // Do not add auto values to either.\n  var result = {\n    insertDoc: ss.clean(Utility.cleanNulls(doc, false, keepEmptyStrings), {\n      isModifier: false,\n      getAutoValues: false,\n      filter: filter,\n      autoConvert: autoConvert,\n      trimStrings: trimStrings\n    }),\n    updateDoc: ss.clean(Utility.docToModifier(doc, keepEmptyStrings), {\n      isModifier: true,\n      getAutoValues: false,\n      filter: filter,\n      autoConvert: autoConvert,\n      trimStrings: trimStrings\n    })\n  };\n  return result;\n};\n\n/*\n * Gets the value that should be shown/selected in the input. Returns\n * a string, a boolean, or an array of strings. The value used,\n * in order of preference, is one of:\n * * The `value` attribute provided\n * * The value that is set in the `doc` provided on the containing autoForm\n * * The `defaultValue` from the schema\n */\ngetInputValue = function getInputValue(name, atts, expectsArray, inputType, value, mDoc, defaultValue) {\n  if (typeof value === \"undefined\") {\n    // Get the value for this key in the current document\n    if (mDoc) {\n      var valueInfo = mDoc.getInfoForKey(name);\n      if (valueInfo) {\n        value = valueInfo.value;\n      }\n    }\n\n    // Only if there is no current document, use the schema defaultValue\n    else if (defaultValue !== null && defaultValue !== undefined) {\n      value = defaultValue;\n    }\n  }\n\n  // Change null or undefined to an empty string\n  value = (value == null) ? '' : value;\n\n  function stringValue(val) {\n    if (val instanceof Date) {\n      //convert Dates to string value based on field inputType\n      if (value instanceof Date) {\n        if (inputType === \"datetime\") {\n          return Utility.dateToNormalizedForcedUtcGlobalDateAndTimeString(val);\n        } else if (inputType === \"datetime-local\") {\n          return Utility.dateToNormalizedLocalDateAndTimeString(val, atts.timezoneId);\n        } else {\n          // This fallback will be used for type=\"date\" as well\n          // as for select arrays, since it would not make much\n          // sense to do anything other than the date portion\n          // in select controls.\n          return Utility.dateToDateStringUTC(val);\n        }\n      }\n    } else if (val.toString) {\n      return val.toString();\n    } else {\n      return val;\n    }\n  }\n\n  // If we're expecting value to be an array, and it's not, make it one\n  if (expectsArray && !_.isArray(value)) {\n    if (typeof value === \"string\") {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n  }\n\n  // Convert to strings\n  if (_.isArray(value)) {\n    value = _.map(value, function (v) {\n      return stringValue(v);\n    });\n  } else {\n    value = stringValue(value);\n  }\n\n  // Switch to a boolean value for boolean fields\n  if (inputType === \"boolean-radios\" || inputType === \"boolean-select\" || inputType === \"boolean-checkbox\") {\n    value = (value === \"true\") ? true : false;\n  }\n\n  // We return either a string, a boolean, or an array of strings\n  return value;\n};\n\ngetInputData = function getInputData(defs, hash, value, inputType, label, expectsArray, submitType, _af) {\n  var schemaType = defs.type;\n\n  // We don't want to alter the original hash, so we clone it and\n  // remove some stuff that should not be HTML attributes\n  // XXX It would be better to use a whitelist of allowed attributes\n  var inputAtts = _.omit(hash,\n          \"autoform\",\n          \"value\",\n          \"firstOption\",\n          \"radio\",\n          \"select\",\n          \"noselect\",\n          \"trueLabel\",\n          \"falseLabel\",\n          \"options\",\n          \"offset\", //deprecated attr, but we'll remove it for now\n          \"timezoneId\",\n          \"template\");\n\n  // Add required to every type of element, if required\n  if (typeof inputAtts.required === \"undefined\" && !defs.optional) {\n    inputAtts.required = \"\";\n  }\n\n  // Add disabled or readonly if the form has that submit type\n  if (submitType === \"disabled\") {\n    inputAtts.disabled = \"\";\n  } else if (submitType === \"readonly\") {\n    inputAtts.readonly = \"\";\n  }\n\n  var min = (typeof defs.min === \"function\") ? defs.min() : defs.min;\n  var max = (typeof defs.max === \"function\") ? defs.max() : defs.max;\n\n  if (inputType === \"datetime-local\") {\n    if (typeof hash.timezoneId === \"string\") {\n      inputAtts[\"data-timezone-id\"] = hash.timezoneId;\n    }\n  }\n\n  // Extract settings from hash\n  var firstOption = hash.firstOption;\n  var radio = hash.radio;\n  var select = hash.select;\n  var noselect = hash.noselect;\n  var trueLabel = hash.trueLabel || \"True\";\n  var falseLabel = hash.falseLabel || \"False\";\n  var selectOptions = hash.options;\n\n  // Handle options=\"allowed\"\n  if (selectOptions === \"allowed\") {\n    selectOptions = _.map(defs.allowedValues, function(v) {\n      var label = v;\n      if (hash.capitalize && v.length > 0 && schemaType === String) {\n        label = v.charAt(0).toUpperCase() + v.slice(1).toLowerCase();\n      }\n\n      return {label: label, value: v};\n    });\n  }\n  // If options are specified in the schema, they may be a function\n  // that has not yet been evaluated.\n  else if (typeof selectOptions === \"function\") {\n    selectOptions = selectOptions();\n  }\n\n  // Set placeholder to label from schema if requested\n  if (hash.placeholder === \"schemaLabel\") {\n    inputAtts.placeholder = label;\n  }\n\n  // To enable reactively toggling boolean attributes\n  // in a simple way, we add the attributes to the HTML\n  // only if their value is `true`. That is, unlike in\n  // HTML, their mere presence does not matter.\n  _.each([\"disabled\", \"readonly\", \"checked\", \"required\", \"autofocus\"], function (booleanProp) {\n    if (!_.has(hash, booleanProp))\n      return;\n\n    // For historical reasons, we treat the string \"true\" and an empty string as `true`, too.\n    // But an empty string value results in the cleanest rendered output for boolean props,\n    // so we standardize as that.\n    if (hash[booleanProp] === true || hash[booleanProp] === \"true\" || hash[booleanProp] === \"\") {\n      inputAtts[booleanProp] = \"\";\n    } else {\n      // If the value is anything else, we don't render it\n      delete inputAtts[booleanProp];\n    }\n  });\n\n  // Add data-schema-key to every type of element\n  inputAtts['data-schema-key'] = inputAtts['name'];\n\n  // Determine what options to use\n  var data = {};\n\n  data.name = inputAtts['name'];\n  data.expectsArray = expectsArray;\n\n  if (selectOptions) {\n    // Build anything that should be a select, which is anything with options\n    data.items = [];\n    // For check boxes, we add the \"autoform-array-item\" class\n    if (noselect && expectsArray) {\n      inputAtts[\"class\"] = (inputAtts[\"class\"] || \"\") + \" autoform-array-item\";\n    }\n    // If rendering a select element\n    if (!noselect) {\n      inputAtts.autocomplete = \"off\"; //can fix issues with some browsers selecting the firstOption instead of the selected option\n      if (expectsArray) {\n        inputAtts.multiple = \"\";\n      }\n      // If a firstOption was provided, add that to the items list first\n      if (firstOption && !expectsArray) {\n        data.items.push({\n          name: data.name,\n          label: firstOption,\n          value: \"\",\n          // _id must be included because it is a special property that\n          // #each uses to track unique list items when adding and removing them\n          // See https://github.com/meteor/meteor/issues/2174\n          _id: \"\",\n          selected: false,\n          atts: inputAtts\n        });\n      }\n    }\n    // Add all defined options\n    _.each(selectOptions, function(opt) {\n      var selected = expectsArray ? _.contains(value, opt.value.toString()) : (opt.value.toString() === value.toString());\n      data.items.push({\n        name: data.name,\n        label: opt.label,\n        value: opt.value,\n        // _id must be included because it is a special property that\n        // #each uses to track unique list items when adding and removing them\n        // See https://github.com/meteor/meteor/issues/2174\n        _id: opt.value,\n        selected: selected,\n        atts: inputAtts\n      });\n    });\n  } else if (inputType === \"textarea\") {\n    if (typeof inputAtts.maxlength === \"undefined\" && typeof max === \"number\") {\n      inputAtts.maxlength = max;\n    }\n    data.value = value;\n  } else if (inputType === \"contenteditable\") {\n    if (typeof inputAtts['data-maxlength'] === \"undefined\" && typeof max === \"number\") {\n      inputAtts['data-maxlength'] = max;\n    }\n    data.value = value;\n  } else if (inputType === \"boolean-radios\" || inputType === \"boolean-select\" || inputType === \"boolean-checkbox\") {\n\n    // add autoform-boolean class, which we use when building object\n    // from form values later\n    inputAtts[\"class\"] = (inputAtts[\"class\"] || \"\") + \" autoform-boolean\";\n\n    function getItems() {\n      return [\n        {\n          name: data.name,\n          value: \"false\",\n          // _id must be included because it is a special property that\n          // #each uses to track unique list items when adding and removing them\n          // See https://github.com/meteor/meteor/issues/2174\n          _id: \"false\",\n          selected: !value,\n          label: falseLabel,\n          atts: inputAtts\n        },\n        {\n          name: data.name,\n          value: \"true\",\n          // _id must be included because it is a special property that\n          // #each uses to track unique list items when adding and removing them\n          // See https://github.com/meteor/meteor/issues/2174\n          _id: \"true\",\n          selected: value,\n          label: trueLabel,\n          atts: inputAtts\n        }\n      ];\n    }\n    \n    if (inputType === \"boolean-radios\" || inputType === \"boolean-select\") {\n      data.items = getItems();\n    } else {\n      //don't add required attribute to checkboxes because some browsers assume that to mean that it must be checked, which is not what we mean by \"required\"\n      delete inputAtts.required;\n      data.value = \"true\";\n      data.selected = value;\n    }\n  } else {\n    // All other inputTypes\n    switch (inputType) {\n      case \"number\":\n        if (typeof inputAtts.max === \"undefined\" && typeof max === \"number\") {\n          inputAtts.max = max;\n        }\n        if (typeof inputAtts.min === \"undefined\" && typeof min === \"number\") {\n          inputAtts.min = min;\n        }\n        if (typeof inputAtts.step === \"undefined\" && defs.decimal) {\n          inputAtts.step = '0.01';\n        }\n        break;\n      case \"date\":\n        if (typeof inputAtts.max === \"undefined\" && max instanceof Date) {\n          inputAtts.max = Utility.dateToDateStringUTC(max);\n        }\n        if (typeof inputAtts.min === \"undefined\" && min instanceof Date) {\n          inputAtts.min = Utility.dateToDateStringUTC(min);\n        }\n        break;\n      case \"datetime\":\n        if (typeof inputAtts.max === \"undefined\" && max instanceof Date) {\n          inputAtts.max = Utility.dateToNormalizedForcedUtcGlobalDateAndTimeString(max);\n        }\n        if (typeof inputAtts.min === \"undefined\" && min instanceof Date) {\n          inputAtts.min = Utility.dateToNormalizedForcedUtcGlobalDateAndTimeString(min);\n        }\n        break;\n      case \"datetime-local\":\n        if (typeof inputAtts.max === \"undefined\" && max instanceof Date) {\n          inputAtts.max = Utility.dateToNormalizedLocalDateAndTimeString(max, inputAtts[\"data-timezone-id\"]);\n        }\n        if (typeof inputAtts.min === \"undefined\" && min instanceof Date) {\n          inputAtts.min = Utility.dateToNormalizedLocalDateAndTimeString(min, inputAtts[\"data-timezone-id\"]);\n        }\n        break;\n      case \"hidden\":\n        if (schemaType === Boolean) {\n          // add autoform-boolean class, which we use when building object\n          // from form values later\n          inputAtts[\"class\"] = (inputAtts[\"class\"] || \"\") + \" autoform-boolean\";\n        }\n    }\n\n    if (typeof inputAtts.maxlength === \"undefined\"\n            && typeof max === \"number\"\n            && _.contains([\"text\", \"email\", \"search\", \"password\", \"tel\", \"url\"], inputType)\n            ) {\n      inputAtts.maxlength = max;\n    }\n\n    data.type = inputType;\n    data.value = value;\n  }\n\n  // We set this one down here because some of the code paths above alter inputAtts\n  data.atts = inputAtts;\n\n  return data;\n};\n\ngetInputTemplateType = function getInputTemplateType(type) {\n  // Special types\n  var typeMap = {\n    \"select\": \"afSelect\",\n    \"select-checkbox\": \"afCheckboxGroup\",\n    \"select-radio\": \"afRadioGroup\",\n    \"textarea\": \"afTextarea\",\n    \"contenteditable\": \"afContenteditable\",\n    \"boolean-radios\": \"afRadioGroup\",\n    \"boolean-select\": \"afSelect\",\n    \"boolean-checkbox\": \"afCheckbox\",\n  };\n\n  // All other input types\n  var defaultTemplateType = \"afInput\";\n  \n  return typeMap[type] || defaultTemplateType;\n};\n\nupdateTrackedFieldValue = function updateTrackedFieldValue(formId, key, val) {\n  formValues[formId] = formValues[formId] || {};\n  formValues[formId][key] = formValues[formId][key] || {_deps: new Deps.Dependency};\n  formValues[formId][key]._val = val;\n  formValues[formId][key]._deps.changed();\n};\n\nupdateAllTrackedFieldValues = function updateAllTrackedFieldValues(formId) {\n  var template = templatesById[formId];\n  if (!template)\n    return;\n  _.each(formValues[formId], function (o, key) {\n    updateTrackedFieldValue(formId, key, getFieldValue(template, key));\n  });\n};\n\ninvalidateFormContext = function invalidateFormContext(formId) {\n  formDeps[formId] = formDeps[formId] || new Deps.Dependency;\n  formDeps[formId].changed();\n};\n","\nTemplate.__checkName(\"autoForm\");\nTemplate[\"autoForm\"] = new Template(\"Template.autoForm\", (function() {\n  var view = this;\n  return HTML.FORM(HTML.Attrs(function() {\n    return Spacebars.attrMustache(view.lookup(\"atts\"));\n  }), \"\\n    \", Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), view.lookup(\"..\"));\n  }, function() {\n    return [ \"\\n    \", Blaze._InOuterTemplateScope(view, function() {\n      return Blaze._TemplateWith(function() {\n        return Spacebars.call(view.lookup(\".\"));\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(view.templateContentBlock);\n        });\n      });\n    }), \"\\n    \" ];\n  }), \"\\n  \");\n}));\n","Template.autoForm.helpers({\n  atts: function autoFormTplAtts() {\n    var context = _.clone(this);\n\n    // By default, we add the `novalidate=\"novalidate\"` attribute to our form,\n    // unless the user passes `validation=\"browser\"`.\n    if (context.validation !== \"browser\" && !context.novalidate) {\n      context.novalidate = \"novalidate\";\n    }\n    // After removing all of the props we know about, everything else should\n    // become a form attribute.\n    // XXX Would be better to use a whitelist of HTML attributes allowed on form elements\n    return _.omit(context, \"schema\", \"collection\", \"validation\", \"doc\", \"resetOnSuccess\",\n        \"type\", \"template\", \"autosave\", \"meteormethod\", \"filter\", \"autoConvert\", \"removeEmptyStrings\", \"trimStrings\");\n  },\n  innerContext: function autoFormTplContext(outerContext) {\n    var context = this;\n    var formId = context.id || defaultFormId;\n    var collection = Utility.lookup(context.collection);\n    var ss = Utility.getSimpleSchemaFromContext(context, formId);\n\n    // Retain doc values after a \"hot code push\", if possible\n    var retrievedDoc = formPreserve.getDocument(formId);\n    if (retrievedDoc !== false) {\n      // Ensure we keep the _id property which may not be present in retrievedDoc.\n      context.doc = _.extend({}, context.doc || {}, retrievedDoc);\n    }\n\n    var mDoc;\n    if (context.doc && !_.isEmpty(context.doc)) {\n      // Clone doc\n      var copy = _.clone(context.doc);\n      var hookCtx = {formId: formId};\n      // Pass doc through docToForm hooks\n      _.each(Hooks.getHooks(formId, 'docToForm'), function autoFormEachDocToForm(hook) {\n        copy = hook.call(hookCtx, copy, ss, formId);\n      });\n      // Create a \"flat doc\" that can be used to easily get values for corresponding\n      // form fields.\n      mDoc = new MongoObject(copy);\n      fd.sourceDoc(formId, mDoc);\n    } else {\n      fd.sourceDoc(formId, null);\n    }\n\n    // Check autosave\n    var autosave, resetOnSuccess;\n    if (context.autosave === true && context.type === \"update\") {\n      // Autosave and never reset on success\n      autosave = true;\n      resetOnSuccess = false;\n    } else {\n      autosave = false;\n      resetOnSuccess = context.resetOnSuccess;\n    }\n\n    // Set up the context to be used for everything within the autoform.\n    var innerContext = {_af: {\n      formId: formId,\n      collection: collection,\n      ss: ss,\n      ssIsOverride: !!collection && !!context.schema,\n      doc: context.doc || null,\n      mDoc: mDoc,\n      validationType: (context.validation == null ? \"submitThenKeyup\" : context.validation),\n      submitType: context.type,\n      submitMethod: context.meteormethod,\n      resetOnSuccess: resetOnSuccess,\n      autosave: autosave,\n      filter: context.filter,\n      autoConvert: context.autoConvert,\n      removeEmptyStrings: context.removeEmptyStrings,\n      trimStrings: context.trimStrings\n    }};\n\n    // Cache context for lookup by formId\n    formData[formId] = innerContext._af;\n\n    // When we change the form, loading a different doc, reloading the current doc, etc.,\n    // we also want to reset the array counts for the form\n    arrayTracker.resetForm(formId);\n\n    // Preserve outer context, allowing access within autoForm block without needing ..\n    _.extend(innerContext, outerContext);\n    return innerContext;\n  }\n});\n\nTemplate.autoForm.created = function autoFormCreated() {\n  var self = this;\n  var formId = self.data.id || defaultFormId;\n  // Add to templatesById list\n  templatesById[formId] = self;\n};\n\nTemplate.autoForm.destroyed = function autoFormDestroyed() {\n  var self = this;\n  self._notInDOM = true;\n  var formId = self.data.id || defaultFormId;\n\n  // Remove from templatesById list\n  if (templatesById[formId]) {\n    delete templatesById[formId];\n  }\n\n  // Remove from data list\n  if (formData[formId]) {\n    delete formData[formId];\n  }\n\n  // Remove from array fields list\n  arrayTracker.untrackForm(formId);\n\n  // Remove from field values\n  if (formValues[formId]) {\n    delete formValues[formId];\n  }\n\n  // Unregister form preservation\n  formPreserve.unregisterForm(formId);\n};","\nTemplate.__checkName(\"quickForm\");\nTemplate[\"quickForm\"] = new Template(\"Template.quickForm\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), view.lookup(\".\"));\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), \"quickForm\", Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.quickForm.helpers({\n  innerContext: function quickFormContext(atts) {\n    // Pass along quickForm context to autoForm context, minus a few\n    // properties that are specific to quickForms.\n    var qfAutoFormContext = _.omit(atts, \"buttonContent\", \"buttonClasses\", \"fields\", \"omitFields\");\n\n    return {\n      qfAutoFormContext: qfAutoFormContext,\n      atts: atts,\n      // qfShouldRenderButton helper\n      qfShouldRenderButton: function qfShouldRenderButton() {\n        var self = this;\n        var qfAtts = self.atts;\n        var submitType = self._af.submitType;\n        return (qfAtts.buttonContent !== false && submitType !== \"readonly\" && submitType !== \"disabled\");\n      }\n    };\n  }\n});","\nTemplate.__checkName(\"afArrayField\");\nTemplate[\"afArrayField\"] = new Template(\"Template.afArrayField\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), Spacebars.kw({\n      atts: view.lookup(\".\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), \"afArrayField\", Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.afArrayField.helpers({\n  innerContext: function afArrayFieldContext(options) {\n    var c = Utility.normalizeContext(options.hash, \"afArrayField\");\n    var name = c.atts.name;\n    var fieldMinCount = c.atts.minCount || 0;\n    var fieldMaxCount = c.atts.maxCount || Infinity;\n    var ss = c.af.ss;\n    var formId = c.af.formId;\n\n    // Init the array tracking for this field\n    var docCount = fd.getDocCountForField(formId, name);\n    if (docCount == null) {\n      docCount = c.atts.initialCount;\n    }\n    arrayTracker.initField(formId, name, ss, docCount, fieldMinCount, fieldMaxCount);\n\n    return {\n      atts: c.atts\n    };\n  }\n});","\nTemplate.__checkName(\"afEachArrayItem\");\nTemplate[\"afEachArrayItem\"] = new Template(\"Template.afEachArrayItem\", (function() {\n  var view = this;\n  return [ \"\\n  \", Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), Spacebars.kw({\n      atts: view.lookup(\".\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Blaze.Each(function() {\n      return Spacebars.call(view.lookup(\".\"));\n    }, function() {\n      return [ \"\\n    \", Blaze.If(function() {\n        return Spacebars.call(Spacebars.dot(view.lookup(\".\"), \"removed\"));\n      }, function() {\n        return [ \"\\n    \", HTML.INPUT({\n          type: \"hidden\",\n          name: function() {\n            return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"name\"));\n          },\n          \"data-schema-key\": function() {\n            return Spacebars.mustache(Spacebars.dot(view.lookup(\".\"), \"name\"));\n          },\n          \"data-null-value\": \"true\",\n          value: \"\"\n        }), \"\\n    \" ];\n      }, function() {\n        return [ \"\\n    \", Blaze._InOuterTemplateScope(view, function() {\n          return Blaze._TemplateWith(function() {\n            return Spacebars.call(view.lookup(\".\"));\n          }, function() {\n            return Spacebars.include(function() {\n              return Spacebars.call(view.templateContentBlock);\n            });\n          });\n        }), \"\\n    \" ];\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  }) ];\n}));\n","Template.afEachArrayItem.helpers({\n  innerContext: function afEachArrayItemContext(options) {\n    var c = Utility.normalizeContext(options.hash, \"afEachArrayItem\");\n    var formId = c.af.formId;\n    var name = c.atts.name;\n\n    var docCount = fd.getDocCountForField(formId, name);\n    if (docCount == null) {\n      docCount = c.atts.initialCount;\n    }\n    arrayTracker.initField(formId, name, c.af.ss, docCount, c.atts.minCount, c.atts.maxCount);\n    \n    return arrayTracker.getField(formId, name);\n  }\n});","\nTemplate.__checkName(\"afFieldInput\");\nTemplate[\"afFieldInput\"] = new Template(\"Template.afFieldInput\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), Spacebars.kw({\n      atts: view.lookup(\".\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), view.lookup(\"getTemplateType\"), Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.afFieldInput.helpers({\n  getTemplateType: function afFieldInputGetTemplateType() {\n    return getInputTemplateType(this.type);\n  },\n  innerContext: function afFieldInputContext(options) {\n    var c = Utility.normalizeContext(options.hash, \"afFieldInput and afFieldSelect\");\n    var contentBlock = options.hash.contentBlock; // applies only to afFieldSelect\n    var contentBlockContext = options.hash.contentBlockContext; // applies only to afFieldSelect\n\n    // Set up deps, allowing us to re-render the form\n    formDeps[c.af.formId] = formDeps[c.af.formId] || new Deps.Dependency;\n    formDeps[c.af.formId].depend();\n\n    var ss = c.af.ss;\n    var defs = c.defs;\n\n    var fieldExpectsArray = AutoForm.expectsArray(c.atts);\n\n    // Adjust for array fields if necessary\n    var defaultValue = defs.defaultValue; //make sure to use pre-adjustment defaultValue for arrays\n    if (defs.type === Array) {\n      defs = ss.schema(c.atts.name + \".$\");\n    }\n\n    // Get inputType\n    var inputType = AutoForm.getInputType(c.atts);\n\n    // Get input value\n    var value = getInputValue(c.atts.name, c.atts, fieldExpectsArray, inputType, c.atts.value, c.af.mDoc, defaultValue);\n\n    // Track field's value for reactive show/hide of other fields by value\n    updateTrackedFieldValue(c.af.formId, c.atts.name, value);\n    \n    // Get input data context\n    var iData = getInputData(defs, c.atts, value, inputType, ss.label(c.atts.name), fieldExpectsArray, c.af.submitType, c.af);\n\n    // Return input data context\n    return _.extend({_af: c.af, contentBlock: contentBlock, contentBlockContext: contentBlockContext, type: inputType}, iData);\n  }\n});","\nTemplate.__checkName(\"afFieldLabel\");\nTemplate[\"afFieldLabel\"] = new Template(\"Template.afFieldLabel\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return {\n      atts: Spacebars.call(view.lookup(\".\"))\n    };\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), \"afFieldLabel\", Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","\nTemplate.__checkName(\"afFieldSelect\");\nTemplate[\"afFieldSelect\"] = new Template(\"Template.afFieldSelect\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), Spacebars.kw({\n      atts: view.lookup(\".\"),\n      contentBlock: view.templateContentBlock,\n      contentBlockContext: view.lookup(\"..\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), \"afFieldSelect\", Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.afFieldSelect.helpers({\n  innerContext: Template.afFieldInput.innerContext\n});","\nTemplate.__checkName(\"afFormGroup\");\nTemplate[\"afFormGroup\"] = new Template(\"Template.afFormGroup\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return Spacebars.dataMustache(view.lookup(\"innerContext\"), Spacebars.kw({\n      atts: view.lookup(\".\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), \"afFormGroup\", Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.afFormGroup.helpers({\n  innerContext: function afFormGroupContext(options) {\n    var c = Utility.normalizeContext(options.hash, \"afFormGroup\");\n    return {\n      skipLabel: (c.atts.label === false),\n      afFieldLabelAtts: formGroupLabelAtts(c.atts),\n      afFieldInputAtts: formGroupInputAtts(c.atts),\n      atts: {name: c.atts.name}\n    };\n  }\n});\n\n/*\n * Private\n */\n\nfunction formGroupLabelAtts(atts) {\n  // Separate label options from input options; label items begin with \"label-\"\n  var labelAtts = {\n    name: atts.name,\n    template: atts.template\n  };\n  _.each(atts, function autoFormLabelAttsEach(val, key) {\n    if (key.indexOf(\"label-\") === 0) {\n      labelAtts[key.substring(6)] = val;\n    }\n  });\n\n  return labelAtts;\n}\n\nfunction formGroupInputAtts(atts) {\n  // Separate label options from input options; label items begin with \"label-\"\n  // We also don't want the \"label\" option\n  return _.omit(atts, function (val, key) {\n    return (key === \"label\" || key.indexOf(\"label-\") === 0);\n  });\n}","\nTemplate.__checkName(\"afObjectField\");\nTemplate[\"afObjectField\"] = new Template(\"Template.afObjectField\", (function() {\n  var view = this;\n  return Spacebars.With(function() {\n    return {\n      atts: Spacebars.call(view.lookup(\".\"))\n    };\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return Spacebars.dataMustache(view.lookup(\"afTemplateName\"), \"afObjectField\", Spacebars.dot(view.lookup(\"..\"), \"template\"));\n    }, function() {\n      return [ \"\\n      \", Blaze._TemplateWith(function() {\n        return {\n          template: Spacebars.call(view.lookup(\".\")),\n          data: Spacebars.call(view.lookup(\"..\"))\n        };\n      }, function() {\n        return Spacebars.include(function() {\n          return Spacebars.call(Template.__dynamic);\n        });\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","\nTemplate.__checkName(\"afQuickField\");\nTemplate[\"afQuickField\"] = new Template(\"Template.afQuickField\", (function() {\n  var view = this;\n  return Blaze.If(function() {\n    return Spacebars.dataMustache(view.lookup(\"isGroup\"), Spacebars.kw({\n      atts: view.lookup(\".\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Spacebars.include(view.lookupTemplate(\"afObjectField\")), \"\\n  \" ];\n  }, function() {\n    return [ \"\\n    \", Blaze.If(function() {\n      return Spacebars.dataMustache(view.lookup(\"isFieldArray\"), Spacebars.kw({\n        atts: view.lookup(\".\")\n      }));\n    }, function() {\n      return [ \"\\n      \", Spacebars.include(view.lookupTemplate(\"afArrayField\")), \"\\n    \" ];\n    }, function() {\n      return [ \"\\n      \", Spacebars.include(view.lookupTemplate(\"afFormGroup\")), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.afQuickField.helpers({\n  isGroup: function afQuickFieldIsGroup(options) {\n    var c = Utility.normalizeContext(options.hash, \"afQuickField\");\n    // Render an array of fields if we expect an Object and we don't have options\n    // and we have not overridden the type\n    return (c.defs.type === Object && !c.atts.options && !c.atts.type);\n  },\n  isFieldArray: function afQuickFieldIsFieldArray(options) {\n    var c = Utility.normalizeContext(options.hash, \"afQuickField\");\n    // Render an array of fields if we expect an Array and we don't have options\n    // and we have not overridden the type\n    return (c.defs.type === Array && !c.atts.options && !c.atts.type);\n  }\n});","\nTemplate.__checkName(\"afQuickFields\");\nTemplate[\"afQuickFields\"] = new Template(\"Template.afQuickFields\", (function() {\n  var view = this;\n  return Blaze.Each(function() {\n    return Spacebars.dataMustache(view.lookup(\"afFieldNames\"), Spacebars.kw({\n      name: Spacebars.dot(view.lookup(\".\"), \"name\"),\n      fields: Spacebars.dot(view.lookup(\".\"), \"fields\"),\n      omitFields: Spacebars.dot(view.lookup(\".\"), \"omitFields\")\n    }));\n  }, function() {\n    return [ \"\\n    \", Spacebars.With(function() {\n      return {\n        name: Spacebars.call(view.lookup(\".\"))\n      };\n    }, function() {\n      return [ \"\\n    \", Blaze._TemplateWith(function() {\n        return Spacebars.call(view.lookup(\"quickFieldAtts\"));\n      }, function() {\n        return Spacebars.include(view.lookupTemplate(\"afQuickField\"));\n      }), \"\\n    \" ];\n    }), \"\\n  \" ];\n  });\n}));\n","Template.afQuickFields.helpers({\n  quickFieldAtts: function afQuickFieldsQuickFieldAtts() {\n    return _.extend({options: \"auto\"}, UI._parentData(2), this);\n  }\n});","// Global template helpers (exported)\n\nvar regHelper = Template.registerHelper;\nif (typeof regHelper !== \"function\") {\n  regHelper = UI.registerHelper;\n}\n\n/*\n * afFieldMessage\n */\nregHelper('afFieldMessage', function autoFormFieldMessage(options) {\n  options = parseOptions(options, 'afFieldMessage');\n\n  return options.ss.namedContext(options.formId).keyErrorMessage(options.name);\n});\n\n/*\n * afFieldIsInvalid\n */\nregHelper('afFieldIsInvalid', function autoFormFieldIsInvalid(options) {\n  options = parseOptions(options, 'afFieldIsInvalid');\n\n  return options.ss.namedContext(options.formId).keyIsInvalid(options.name);\n});\n\n/*\n * afArrayFieldHasMoreThanMinimum\n */\nregHelper('afArrayFieldHasMoreThanMinimum', function autoFormArrayFieldHasMoreThanMinimum(options) {\n  options = parseOptions(options, 'afArrayFieldHasMoreThanMinimum');\n\n  var range = arrayTracker.getMinMax(options.ss, options.name, options.minCount, options.maxCount);\n  var visibleCount = arrayTracker.getVisibleCount(options.formId, options.name);\n  return (visibleCount > range.minCount);\n});\n\n/*\n * afArrayFieldHasLessThanMaximum\n */\nregHelper('afArrayFieldHasLessThanMaximum', function autoFormArrayFieldHasLessThanMaximum(options) {\n  options = parseOptions(options, 'afArrayFieldHasLessThanMaximum');\n\n  var range = arrayTracker.getMinMax(options.ss, options.name, options.minCount, options.maxCount);\n  var visibleCount = arrayTracker.getVisibleCount(options.formId, options.name);\n  return (visibleCount < range.maxCount);\n});\n\n/*\n * afFieldValueIs\n */\nregHelper('afFieldValueIs', function autoFormFieldValueIs(options) {\n  options = parseOptions(options, 'afFieldValueIs');\n\n  var currentValue = AutoForm.getFieldValue(options.formId, options.name);\n  return currentValue === options.value;\n});\n\n/*\n * afArrayFieldIsFirstVisible\n */\nregHelper('afArrayFieldIsFirstVisible', function autoFormArrayFieldIsFirstVisible() {\n  var context = this;\n  return arrayTracker.isFirstFieldlVisible(context.formId, context.arrayFieldName, context.index);\n});\n\n/*\n * afArrayFieldIsLastVisible\n */\nregHelper('afArrayFieldIsLastVisible', function autoFormArrayFieldIsLastVisible() {\n  var context = this;\n  return arrayTracker.isLastFieldlVisible(context.formId, context.arrayFieldName, context.index);\n});\n\n/*\n * afFieldValueContains\n */\nregHelper('afFieldValueContains', function autoFormFieldValueContains(options) {\n  options = parseOptions(options, 'afFieldValueContains');\n\n  var currentValue = AutoForm.getFieldValue(options.formId, options.name);\n  return _.isArray(currentValue) && _.contains(currentValue, options.value);\n});\n\n/*\n * afFieldLabelText\n */\nregHelper('afFieldLabelText', function autoFormFieldLabelText(options) {\n  options = parseOptions(options, 'afFieldLabelText');\n\n  return options.ss.label(options.name);\n});\n\n/*\n * afFieldNames\n */\nregHelper(\"afFieldNames\", function autoFormFieldNames(options) {\n  options = parseOptions(options, 'afFieldNames');\n  var ss = options.ss;\n  var name = options.name;\n\n  // Get the list of fields we want included\n  var fieldList = options.fields;\n  if (fieldList) {\n    fieldList = Utility.stringToArray(fieldList, 'AutoForm: fields attribute must be an array or a string containing a comma-delimited list of fields');\n  } else if (name) {\n    // If we weren't given a fieldList but were given a field name, use subfields by default\n    \n    // Get list of field names that are descendants of this field's name\n    fieldList = ss.objectKeys(SimpleSchema._makeGeneric(name));\n\n    // Tack child field name on to end of parent field name. This\n    // ensures that we keep the desired array index for array items.\n    fieldList = _.map(fieldList, function (field) {\n      return name + \".\" + field;\n    });\n  } else {\n    // If we weren't given a fieldList or a field name, use all first level schema keys by default\n    fieldList = ss.objectKeys() || [];\n  }\n\n  // If user wants to omit some fields, remove those from the array\n  var omitFields = options.omitFields;\n  if (omitFields) {\n    omitFields = Utility.stringToArray(omitFields, 'AutoForm: omitFields attribute must be an array or a string containing a comma-delimited list of fields');\n    fieldList = _.difference(fieldList, omitFields);\n    // If omitFields contains generic field names (with $) we omit those too\n    fieldList = _.reject(fieldList, function (f) {\n      return _.contains(omitFields, SimpleSchema._makeGeneric(f));\n    });\n  }\n\n  // Filter out fields we never want\n  fieldList = _.filter(fieldList, function shouldIncludeField(field) {\n    var fieldDefs = ss.schema(field);\n\n    // Don't include fields with autoform.omit=true\n    if (fieldDefs.autoform && fieldDefs.autoform.omit === true)\n      return false;\n\n    // Don't include fields with denyInsert=true when it's an insert form\n    if (fieldDefs.denyInsert && options.submitType === \"insert\")\n      return false;\n\n    // Don't include fields with denyUpdate=true when it's an update form\n    if (fieldDefs.denyUpdate && options.submitType === \"update\")\n      return false;\n\n    return true;\n  });\n\n  // Ensure fields are not added more than once\n  fieldList = _.unique(fieldList);\n\n  return fieldList;\n});\n\n/*\n * afTemplateName\n */\nregHelper('afTemplateName', function afTemplateNameHelper(templateType, templateName) {\n  var self = this;\n  \n  // Template may be specified in schema.\n  // Skip for quickForm because it renders a form and not a field.\n  if (!templateName && templateType !== 'quickForm') {\n    var autoform = AutoForm.find(templateType);\n    var fieldName = self.name;\n    \n    if (fieldName && autoform) {\n      var defs = Utility.getDefs(autoform.ss, fieldName); //defs will not be undefined\n      templateName = (defs.autoform && defs.autoform.template);\n    }\n  }\n\n  // Determine default template\n  var defaultTemplate = AutoForm.getDefaultTemplateForType(templateType) || AutoForm.getDefaultTemplate();\n\n  // Determine template name\n  var result;\n  if (templateName) {\n    result = templateType + '_' + templateName;\n    if (!Template[result]) {\n      result = null;\n      AutoForm._debug && console.warn(templateType + ': \"' + templateName + '\" is not a valid template name. Falling back to default template, \"' + defaultTemplate + '\".');\n    }\n  }\n\n  if (!result) {\n    result = templateType + '_' + defaultTemplate;\n    if (!Template[result]) {\n      throw new Error(templateType + ': \"' + defaultTemplate + '\" is not a valid template name');\n    }\n  }\n\n  // Return the template name that we want to use\n  return result;\n});\n\n/*\n * PRIVATE\n */\n\nfunction parseOptions(options, helperName) {\n  var hash = (options || {}).hash || {};\n  // Find the autoform context\n  var afContext = AutoForm.find(helperName);\n  // Call getDefs for side effect of throwing errors when name is not in schema\n  hash.name && Utility.getDefs(afContext.ss, hash.name);\n  return _.extend({}, afContext, hash);\n}","// all form validation logic is here\n\n_validateForm = function _validateForm(formId, formDetails, formDocs, useCollectionSchema) {\n  if (formDetails.validationType === 'none')\n    return true;\n\n  // We use the schema for the `schema` attribute if present,\n  // else the schema for the collection. If there is a `schema`\n  // attribute but you want to force validation against the\n  // collection's schema instead, pass useCollectionSchema=true\n  var ss = (useCollectionSchema && formDetails.collection) ? formDetails.collection.simpleSchema() : formDetails.ss;\n  \n  var docId = formDetails.doc && formDetails.doc._id || null;\n\n  // Perform validation\n  if (formDetails.submitType === \"update\") {\n    // For a type=\"update\" form, we validate the modifier. We don't want to throw\n    // errors about missing required fields, etc.\n    return validateFormDoc(formDocs.updateDoc, true, formId, ss, docId);\n  } else {\n    // For any other type of form, we validate the document.\n    return validateFormDoc(formDocs.insertDoc, false, formId, ss, docId);\n  }\n};\n\nvalidateFormDoc = function validateFormDoc(doc, isModifier, formId, ss, docId, key) {\n  var ec = {\n    userId: (Meteor.userId && Meteor.userId()) || null,\n    isInsert: !isModifier,\n    isUpdate: !!isModifier,\n    isUpsert: false,\n    isFromTrustedCode: false,\n    docId: docId\n  };\n\n  // Get a version of the doc that has auto values to validate here. We\n  // don't want to actually send any auto values to the server because\n  // we ultimately want them generated on the server\n  var docForValidation = ss.clean(_.clone(doc), {\n    isModifier: isModifier,\n    filter: false,\n    autoConvert: false,\n    trimStrings: false,\n    extendAutoValueContext: ec\n  });\n\n  // Validate\n  // If `key` is provided, we validate that key/field only\n  if (key) {\n    return ss.namedContext(formId).validateOne(docForValidation, key, {\n      modifier: isModifier,\n      extendedCustomContext: ec\n    });\n  } else {\n    return ss.namedContext(formId).validate(docForValidation, {\n      modifier: isModifier,\n      extendedCustomContext: ec\n    });\n  }\n};\n\n_validateField = function _validateField(key, template, skipEmpty, onlyIfAlreadyInvalid) {\n  if (!template || template._notInDOM) {\n    return; //skip validation\n  }\n\n  var context = template.data;\n  var formId = context.id || defaultFormId;\n  var formDetails = formData[formId];\n  var docId = formDetails.doc && formDetails.doc._id || null;\n  var ss = formDetails.ss;\n\n  if (onlyIfAlreadyInvalid && ss.namedContext(formId).isValid()) {\n    return; //skip validation\n  }\n\n  // Create a document based on all the values of all the inputs on the form\n  var formDocs = getFormValues(template, formId, ss);\n\n  // Clean and validate doc\n  if (formDetails.submitType === \"update\") {\n    var docToValidate = formDocs.updateDoc;\n    var isModifier = true;\n  } else {\n    var docToValidate = formDocs.insertDoc;\n    var isModifier = false;\n  }\n\n  // Skip validation if skipEmpty is true and the field we're validating\n  // has no value.\n  if (skipEmpty && !Utility.objAffectsKey(docToValidate, key))\n    return true; //skip validation\n\n  return validateFormDoc(docToValidate, isModifier, formId, ss, docId, key);\n};\n\n//throttling function that calls out to _validateField\nvar vok = {}, tm = {}, _prevent = false;\nvalidateField = function validateField(key, template, skipEmpty, onlyIfAlreadyInvalid) {\n  if (vok[key] === false) {\n    Meteor.clearTimeout(tm[key]);\n    tm[key] = Meteor.setTimeout(function() {\n      vok[key] = true;\n      if (!_prevent) {\n        _validateField(key, template, skipEmpty, onlyIfAlreadyInvalid);\n      }\n    }, 300);\n    return;\n  }\n  vok[key] = false;\n  if (!_prevent) {\n    _validateField(key, template, skipEmpty, onlyIfAlreadyInvalid);\n  }\n};\n\n// To prevent issues with keyup validation firing right after we've\n// invalidated due to submission, we can quickly and temporarily stop\n// field validation.\npreventQueuedValidation = function preventQueuedValidation() {\n  _prevent = true;\n  Meteor.setTimeout(function() {\n    _prevent = false;\n  }, 500);\n};\n\n// Prep function to select the focus the first field with an error\nselectFirstInvalidField = function selectFirstInvalidField(formId, ss, template) {\n  var ctx = ss.namedContext(formId);\n  if (!ctx.isValid()) {\n    // Exclude fields in sub-forms, since they will belong to a different AutoForm and schema.\n    var fields = template.$('[data-schema-key]').not(template.$('form form [data-schema-key]'));\n    fields.each(function () {\n      var f = $(this);\n      if (ctx.keyIsInvalid(f.attr('data-schema-key'))) {\n        f.focus();\n        return false;\n      }\n    });\n  }\n};","// all form events handled here\nvar lastAutoSaveElement = null;\n\nfunction beginSubmit(formId, template) {\n  if (!template || template._notInDOM)\n    return;\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'beginSubmit');\n  if (hooks.length) {\n    _.each(hooks, function beginSubmitHooks(hook) {\n      hook(formId, template);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n    if (submitButton) {\n      submitButton.disabled = true;\n    }\n  }\n}\n\nfunction endSubmit(formId, template) {\n  if (!template || template._notInDOM)\n    return;\n  // Try to avoid incorrect reporting of which input caused autosave\n  lastAutoSaveElement = null;\n  // Get user-defined hooks\n  var hooks = Hooks.getHooks(formId, 'endSubmit');\n  if (hooks.length) {\n    _.each(hooks, function endSubmitHooks(hook) {\n      hook(formId, template);\n    });\n  } else {\n    // If there are no user-defined hooks, by default we disable the submit button during submission\n    var submitButton = template.find(\"button[type=submit]\") || template.find(\"input[type=submit]\");\n    if (submitButton) {\n      submitButton.disabled = false;\n    }\n  }\n}\n\nTemplate.autoForm.events({\n  'submit form': function autoFormSubmitHandler(event, template) {\n    // Gather necessary form info\n    var formId = this.id || defaultFormId;\n    var data = formData[formId];\n    var isInsert = (data.submitType === \"insert\");\n    var isUpdate = (data.submitType === \"update\");\n    var isMethod = (data.submitType === \"method\");\n    var method = data.submitMethod;\n    var isNormalSubmit = (!isInsert && !isUpdate && !isMethod);\n    // ss will be the schema for the `schema` attribute if present,\n    // else the schema for the collection\n    var ss = data.ss;\n    var ssIsOverride = data.ssIsOverride;\n    var collection = data.collection;\n    var currentDoc = data.doc;\n    var docId = currentDoc ? currentDoc._id : null;\n    var isValid;\n\n    // Make sure we have a collection if we need one for the requested submit type\n    if (!collection) {\n      if (isInsert)\n        throw new Error(\"AutoForm: You must specify a collection when form type is insert.\");\n      else if (isUpdate)\n        throw new Error(\"AutoForm: You must specify a collection when form type is update.\");\n    }\n\n    // Prevent browser form submission if we're planning to do our own thing\n    if (!isNormalSubmit) {\n      event.preventDefault();\n    }\n\n    // Gather hooks\n    var onSuccess = Hooks.getHooks(formId, 'onSuccess');\n    var onError = Hooks.getHooks(formId, 'onError');\n\n    // Prep haltSubmission function\n    function haltSubmission() {\n      event.preventDefault();\n      event.stopPropagation();\n      // Run endSubmit hooks (re-enabled submit button or form, etc.)\n      endSubmit(formId, template);\n    }\n\n    function failedValidation() {\n      selectFirstInvalidField(formId, ss, template);\n      var ec = ss.namedContext(formId);\n      var ik = ec.invalidKeys(), err;\n      if (ik) {\n        if (ik.length) {\n          // We add `message` prop to the invalidKeys.\n          // Maybe SS pkg should just add that property back in?\n          ik = _.map(ik, function (o) {\n            return _.extend({message: ec.keyErrorMessage(o.name)}, o);\n          });\n          err = new Error(ik[0].message);\n        } else {\n          err = new Error('form failed validation');\n        }\n        err.invalidKeys = ik;\n      } else {\n        err = new Error('form failed validation');\n      }\n      _.each(onError, function onErrorEach(hook) {\n        hook('pre-submit validation', err, template);\n      });\n      haltSubmission();\n    }\n\n    // Prep callback creator function\n    function makeCallback(name) {\n      var cbCtx = {\n        event: event,\n        template: template,\n        formId: formId,\n        docId: docId,\n        autoSaveChangedElement: lastAutoSaveElement,\n        resetForm: function () {\n          AutoForm.resetForm(formId, template);\n        }\n      };\n      var afterHooks = Hooks.getHooks(formId, 'after', name);\n      return function autoFormActionCallback(error, result) {\n        if (error) {\n          preventQueuedValidation();\n          selectFirstInvalidField(formId, ss, template);\n          if (onError && onError.length) {\n            _.each(onError, function onErrorEach(hook) {\n              hook.call(cbCtx, name, error, template);\n            });\n          } else if ((!afterHooks || !afterHooks.length) && ss.namedContext(formId).isValid()) {\n            // if there are no onError or \"after\" hooks or validation errors, throw the error\n            // because it must be some other error from the server\n            endSubmit(formId, template);\n            throw error;\n          }\n        } else {\n          // By default, we reset form after successful submit, but\n          // you can opt out.\n          if (data.resetOnSuccess !== false) {\n            AutoForm.resetForm(formId, template);\n          }\n          _.each(onSuccess, function onSuccessEach(hook) {\n            hook.call(cbCtx, name, result, template);\n          });\n        }\n        _.each(afterHooks, function afterHooksEach(hook) {\n          hook.call(cbCtx, error, result, template);\n        });\n        // Run endSubmit hooks (re-enabled submit button or form, etc.)\n        endSubmit(formId, template);\n      };\n    }\n\n    // Prep function that calls before hooks.\n    // We pass the template instance in case the hook\n    // needs the data context.\n    function doBefore(docId, doc, hooks, name, next) {\n      // We call the hooks recursively, in order added,\n      // passing the result of the first hook to the\n      // second hook, etc.\n      function runHook(i, doc) {\n        hook = hooks[i];\n\n        if (!hook) {\n          // We've run all hooks; continue submission\n          next(doc);\n          return;\n        }\n\n        // Set up before hook context\n        var cb = function (d) {\n          // If the hook returns false, we cancel\n          if (d === false) {\n            // Run endSubmit hooks (re-enabled submit button or form, etc.)\n            endSubmit(formId, template);\n          } else {\n            if (!_.isObject(d)) {\n              throw new Error(name + \" must return an object\");\n            }\n            runHook(i+1, d);\n          }\n        };\n        var ctx = {\n          event: event,\n          template: template,\n          formId: formId,\n          docId: docId,\n          autoSaveChangedElement: lastAutoSaveElement,\n          resetForm: function () {\n            AutoForm.resetForm(formId, template);\n          },\n          result: _.once(cb)\n        };\n\n        var result;\n        if (docId) {\n          result = hook.call(ctx, docId, doc, template);\n        } else {\n          result = hook.call(ctx, doc, template);\n        }\n        // If the hook returns undefined, we wait for it\n        // to call this.result()\n        if (result !== void 0) {\n          ctx.result(result);\n        }\n      }\n      \n      runHook(0, doc);\n    }\n\n    // Prep function that calls onSubmit hooks.\n    // We pass the template instance in case the hook\n    // needs the data context, and event in case they\n    // need to prevent default, etc.\n    function doOnSubmit(hooks, insertDoc, updateDoc, currentDoc) {\n      // These are called differently from the before hooks because\n      // they run async, but they can run in parallel and we need the\n      // result of all of them immediately because they can return\n      // false to stop normal form submission.\n\n      var hookCount = hooks.length, doneCount = 0;\n\n      if (hookCount === 0) {\n        // Run endSubmit hooks (re-enabled submit button or form, etc.)\n        endSubmit(formId, template);\n        return;\n      }\n\n      // Set up onSubmit hook context\n      var ctx = {\n        event: event,\n        template: template,\n        formId: formId,\n        docId: docId,\n        autoSaveChangedElement: lastAutoSaveElement,\n        resetForm: function () {\n          AutoForm.resetForm(formId, template);\n        },\n        done: function () {\n          doneCount++;\n          if (doneCount === hookCount) {\n            // Run endSubmit hooks (re-enabled submit button or form, etc.)\n            endSubmit(formId, template);\n          }\n        }\n      };\n\n      // Call all hooks at once.\n      // Pass both types of doc plus the doc attached to the form.\n      // If any return false, we stop normal submission, but we don't\n      // run endSubmit hooks until they all call this.done().\n      var shouldStop = false;\n      _.each(hooks, function eachOnSubmit(hook) {\n        var result = hook.call(ctx, insertDoc, updateDoc, currentDoc);\n        if (shouldStop === false && result === false) {\n          shouldStop = true;\n        }\n      });\n      if (shouldStop) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    // Gather all form values\n    var formDocs = getFormValues(template, formId, ss);\n    var insertDoc = formDocs.insertDoc;\n    var updateDoc = formDocs.updateDoc;\n\n    // Pre-validate\n    // For inserts and updates, which have their\n    // own validation, we validate here only if\n    // there is a `schema` attribute on the form.\n    // Otherwise we let collection2 do the validation\n    // after before hooks have run.\n    if (data.validationType !== 'none' && (ssIsOverride || isMethod || isNormalSubmit)) {\n      // Catch exceptions in validation functions which will bubble up here, cause a form with\n      // onSubmit() to submit prematurely and prevent the error from being reported\n      // (due to a page refresh).\n      try {\n        isValid = _validateForm(formId, data, formDocs);\n      } catch (e) {\n        console.error('Validation error', e);\n        isValid = false;\n      }\n      // If we failed pre-submit validation, we stop submission.\n      if (isValid === false) {\n        return failedValidation();\n      }\n      // NOTE: For method forms when ssIsOverride, we will validate again, later, after before hooks\n      // but before calling the method, against the collection schema\n    }\n\n    // Run beginSubmit hooks (disable submit button or form, etc.)\n    // NOTE: This needs to stay after getFormValues in case a\n    // beginSubmit hook disables inputs. We don't get values for\n    // disabled inputs, but if they are just disabling during submission,\n    // then we actually do want the values.\n    beginSubmit(formId, template);\n\n    // Now we will do the requested insert, update, method, or normal\n    // browser form submission. Even though we may have already validated above,\n    // we do it again upon insert or update\n    // because collection2 validation catches additional stuff like unique and\n    // because our form schema need not be the same as our collection schema.\n    var validationOptions = {\n      validationContext: formId,\n      filter: data.filter,\n      autoConvert: data.autoConvert,\n      removeEmptyStrings: data.removeEmptyStrings,\n      trimStrings: data.trimStrings\n    };\n\n    // INSERT FORM SUBMIT\n    if (isInsert) {\n      // Get \"before.insert\" hooks\n      var beforeInsertHooks = Hooks.getHooks(formId, 'before', 'insert');\n      // Run \"before.insert\" hooks\n      doBefore(null, insertDoc, beforeInsertHooks, 'before.insert hook', function (doc) {\n        // Make callback for insert\n        var insertCallback = makeCallback('insert');\n        // Perform insert\n        if (typeof collection.simpleSchema === \"function\" && collection.simpleSchema() != null) {\n          // If the collection2 pkg is used and a schema is attached, we pass a validationContext\n          collection.insert(doc, validationOptions, insertCallback);\n        } else {\n          // If the collection2 pkg is not used or no schema is attached, we don't pass options\n          // because core Meteor's `insert` function does not accept\n          // an options argument.\n          collection.insert(doc, insertCallback);\n        }\n      });\n    }\n\n    // UPDATE FORM SUBMIT\n    else if (isUpdate) {\n      // Get \"before.update\" hooks\n      var beforeUpdateHooks = Hooks.getHooks(formId, 'before', 'update');\n      // Run \"before.update\" hooks\n      doBefore(docId, updateDoc, beforeUpdateHooks, 'before.update hook', function (modifier) {\n        // Make callback for update\n        var updateCallback = makeCallback('update');\n        if (_.isEmpty(modifier)) { // make sure this check stays after the before hooks\n          // Nothing to update. Just treat it as a successful update.\n          updateCallback(null, 0);\n        }\n        // Perform update\n        collection.update(docId, modifier, validationOptions, updateCallback);\n      });\n    }\n\n    // METHOD FORM SUBMIT\n    else if (isMethod) {\n      // Get \"before.methodName\" hooks\n      if (!method) {\n        throw new Error('When form type is \"method\", you must also provide a \"meteormethod\" attribute');\n      }\n      var beforeMethodHooks = Hooks.getHooks(formId, 'before', method);\n      // Run \"before.methodName\" hooks\n      doBefore(null, insertDoc, beforeMethodHooks, 'before.method hook', function (doc) {\n        // When both `schema` and `collection` are supplied, we do a\n        // second validation now, against the collection schema,\n        // before calling the method.\n        if (ssIsOverride) {\n          isValid = _validateForm(formId, data, formDocs, true);\n          if (isValid === false) {\n            return failedValidation();\n          }\n        }\n        // Make callback for Meteor.call\n        var methodCallback = makeCallback(method);\n        // Call the method\n        Meteor.call(method, doc, updateDoc, docId, methodCallback);\n      });\n    }\n\n    // NORMAL FORM SUBMIT\n    else if (isNormalSubmit) {\n      // Get onSubmit hooks\n      var onSubmitHooks = Hooks.getHooks(formId, 'onSubmit');\n      doOnSubmit(onSubmitHooks, insertDoc, updateDoc, currentDoc);\n    }\n  },\n  'keyup [data-schema-key]': function autoFormKeyUpHandler(event, template) {\n    var validationType = template.data.validation || 'submitThenKeyup';\n    var onlyIfAlreadyInvalid = (validationType === 'submitThenKeyup');\n    var skipEmpty = !(event.keyCode === 8 || event.keyCode === 46); //if deleting or backspacing, don't skip empty\n    if ((validationType === 'keyup' || validationType === 'submitThenKeyup')) {\n      validateField(event.currentTarget.getAttribute(\"data-schema-key\"), template, skipEmpty, onlyIfAlreadyInvalid);\n    }\n  },\n  'blur [data-schema-key]': function autoFormBlurHandler(event, template) {\n    var validationType = template.data.validation || 'submitThenKeyup';\n    var onlyIfAlreadyInvalid = (validationType === 'submitThenKeyup' || validationType === 'submitThenBlur');\n    if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n      validateField(event.currentTarget.getAttribute(\"data-schema-key\"), template, false, onlyIfAlreadyInvalid);\n    }\n  },\n  'change form': function autoFormChangeHandler(event, template) {\n    var self = this;\n\n    var key = event.target.getAttribute(\"data-schema-key\");\n    if (!key)\n      return;\n\n    var formId = self.id || defaultFormId;\n    var data = formData[formId];\n    if (!data)\n      return;\n\n    // Update cached form values for hot code reload persistence\n    if (self.preserveForm !== false) {\n      formPreserve.registerForm(formId, function autoFormRegFormCallback() {\n        return getFormValues(template, formId, data.ss).insertDoc;\n      });\n    }\n\n    // Update field's value for reactive show/hide of other fields by value\n    updateTrackedFieldValue(formId, key, getFieldValue(template, key));\n\n    // If the form should be auto-saved whenever updated, we do that on field\n    // changes instead of validating the field\n    if (data.autosave) {\n      lastAutoSaveElement = event.currentTarget;\n      $(event.currentTarget).submit();\n      return;\n    }\n\n    var validationType = data.validationType || 'submitThenKeyup';\n    var onlyIfAlreadyInvalid = (validationType === 'submitThenKeyup' || validationType === 'submitThenBlur');\n    if (validationType === 'keyup' || validationType === 'blur' || validationType === 'submitThenKeyup' || validationType === 'submitThenBlur') {\n      validateField(key, template, false, onlyIfAlreadyInvalid);\n    }\n  },\n  'reset form': function autoFormResetHandler(event, template) {\n    var formId = this.id || defaultFormId;\n\n    formPreserve.unregisterForm(formId);\n\n    // Reset array counts\n    arrayTracker.resetForm(formId);\n\n    var fd = formData[formId];\n\n    if (!fd)\n      return;\n\n    if (fd.ss) {\n      fd.ss.namedContext(formId).resetValidation();\n      // If simpleSchema is undefined, we haven't yet rendered the form, and therefore\n      // there is no need to reset validation for it. No error need be thrown.\n    }\n\n    //XXX We should ideally be able to call invalidateFormContext\n    // in all cases and that's it, but we need to figure out how\n    // to make Blaze forget about any changes the user made to the form\n    if (this.doc) {\n      event.preventDefault();\n      invalidateFormContext(formId);\n      template.$(\"[autofocus]\").focus();\n    } else {\n      // Update tracked field values\n      // This must be done after we allow this event handler to return\n      // because we have to let the browser reset all fields before we\n      // update their values for deps.\n      Meteor.setTimeout(function () {\n        updateAllTrackedFieldValues(formId);\n        if (template && !template._notInDOM) {\n          template.$(\"[autofocus]\").focus();\n        }\n      }, 0);\n    }\n\n  },\n  'keydown .autoform-array-item input': function (event, template) {\n    // When enter is pressed in an array item field, default behavior\n    // seems to be to \"click\" the remove item button. This doesn't make\n    // sense so we stop it.\n    if (event.keyCode === 13) {\n      event.preventDefault();\n    }\n  },\n  'click .autoform-remove-item': function autoFormClickRemoveItem(event, template) {\n    var self = this; // This type of button must be used within an afEachArrayItem block, so we know the context\n\n    event.preventDefault();\n\n    var name = self.arrayFieldName;\n    var minCount = self.minCount; // optional, overrides schema\n    var maxCount = self.maxCount; // optional, overrides schema\n    var index = self.index;\n    var data = template.data;\n    var formId = data && data.id || defaultFormId;\n    var ss = formData[formId].ss;\n\n    // remove the item we clicked\n    arrayTracker.removeFromFieldAtIndex(formId, name, index, ss, minCount, maxCount);\n  },\n  'click .autoform-add-item': function autoFormClickAddItem(event, template) {\n    event.preventDefault();\n\n    // We pull from data attributes because the button could be manually\n    // added anywhere, so we don't know the data context.\n    var btn = $(event.currentTarget);\n    var name = btn.attr(\"data-autoform-field\");\n    var minCount = btn.attr(\"data-autoform-minCount\"); // optional, overrides schema\n    var maxCount = btn.attr(\"data-autoform-maxCount\"); // optional, overrides schema\n    var data = template.data;\n    var formId = data && data.id || defaultFormId;\n    var ss = formData[formId].ss;\n\n    arrayTracker.addOneToField(formId, name, ss, minCount, maxCount);\n  }\n});\n","// This file defines the public, exported API\n\nAutoForm = AutoForm || {}; //exported\n\nAutoForm.formPreserve = formPreserve;\n\n/**\n * @method AutoForm.addHooks\n * @public\n * @param {String[]|String|null} formIds Form `id` or array of form IDs to which these hooks apply. Specify `null` to add hooks that will run for every form.\n * @param {Object} hooks Hooks to add, where supported names are \"before\", \"after\", \"formToDoc\", \"docToForm\", \"onSubmit\", \"onSuccess\", and \"onError\".\n * @returns {undefined}\n *\n * Defines hooks to be used by one or more forms. Extends hooks lists if called multiple times for the same\n * form.\n */\nAutoForm.addHooks = function autoFormAddHooks(formIds, hooks, replace) {\n  if (typeof formIds === \"string\") {\n    formIds = [formIds];\n  }\n\n  // If formIds is null, add global hooks\n  if (!formIds) {\n    Hooks.addHooksToList(Hooks.global, hooks, replace);\n  } else {\n    _.each(formIds, function (formId) {\n\n      // Init the hooks object if not done yet\n      Hooks.form[formId] = Hooks.form[formId] || {\n        before: {},\n        after: {},\n        formToDoc: [],\n        docToForm: [],\n        onSubmit: [],\n        onSuccess: [],\n        onError: [],\n        beginSubmit: [],\n        endSubmit: []\n      };\n\n      Hooks.addHooksToList(Hooks.form[formId], hooks, replace);\n    });\n  }\n};\n\n/**\n * @method AutoForm.hooks\n * @public\n * @param {Object} hooks\n * @returns {undefined}\n *\n * Defines hooks by form id. Extends hooks lists if called multiple times for the same\n * form.\n */\nAutoForm.hooks = function autoFormHooks(hooks, replace) {\n  _.each(hooks, function(hooksObj, formId) {\n    AutoForm.addHooks(formId, hooksObj, replace);\n  });\n};\n\n/**\n * @method AutoForm.resetForm\n * @public\n * @param {String} formId\n * @param {TemplateInstance} [template] Looked up if not provided. Pass in for efficiency.\n * @returns {undefined}\n *\n * Resets an autoform, including resetting validation errors. The same as clicking the reset button for an autoform.\n */\nAutoForm.resetForm = function autoFormResetForm(formId, template) {\n  template = template || templatesById[formId];\n  if (template && !template._notInDOM) {\n    template.$(\"form\")[0].reset();\n  }\n};\n\n/**\n * @method AutoForm.setDefaultTemplate\n * @public\n * @param {String} template\n */\nAutoForm.setDefaultTemplate = function autoFormSetDefaultTemplate(template) {\n  defaultTemplate = template;\n  deps.defaultTemplate.changed();\n};\n\n/**\n * @method AutoForm.getDefaultTemplate\n * @public\n *\n * Reactive.\n */\nAutoForm.getDefaultTemplate = function autoFormGetDefaultTemplate() {\n  deps.defaultTemplate.depend();\n  return defaultTemplate;\n};\n\n/**\n * @method AutoForm.setDefaultTemplateForType\n * @public\n * @param {String} type\n * @param {String} template\n */\nAutoForm.setDefaultTemplateForType = function autoFormSetDefaultTemplateForType(type, template) {\n  if (!deps.defaultTypeTemplates[type]) {\n    throw new Error(\"invalid template type: \" + type);\n  }\n  if (template !== null && !Template[type + \"_\" + template]) {\n    throw new Error(\"setDefaultTemplateForType can't set default template to \\\"\" + template + \"\\\" for type \\\"\" + type + \"\\\" because there is no defined template with the name \\\"\" + type + \"_\" + template + \"\\\"\");\n  }\n  defaultTypeTemplates[type] = template;\n  deps.defaultTypeTemplates[type].changed();\n};\n\n/**\n * @method AutoForm.getDefaultTemplateForType\n * @public\n * @param {String} type\n * @return {String} Template name\n *\n * Reactive.\n */\nAutoForm.getDefaultTemplateForType = function autoFormGetDefaultTemplateForType(type) {\n  if (!deps.defaultTypeTemplates[type]) {\n    throw new Error(\"invalid template type: \" + type);\n  }\n  deps.defaultTypeTemplates[type].depend();\n  return defaultTypeTemplates[type];\n};\n\n/**\n * @method AutoForm.getFormValues\n * @public\n * @param {String} formId The `id` attribute of the `autoForm` you want current values for.\n * @return {Object}\n *\n * Returns an object representing the current values of all schema-based fields in the form.\n * The returned object contains two properties, \"insertDoc\" and \"updateDoc\", which represent\n * the field values as a normal object and as a MongoDB modifier, respectively.\n */\nAutoForm.getFormValues = function autoFormGetFormValues(formId) {\n  var template = templatesById[formId];\n  if (!template || template._notInDOM) {\n    throw new Error(\"getFormValues: There is currently no autoForm template rendered for the form with id \" + formId);\n  }\n  // Get a reference to the SimpleSchema instance that should be used for\n  // determining what types we want back for each field.\n  var context = template.data;\n  var ss = Utility.getSimpleSchemaFromContext(context, formId);\n  return getFormValues(template, formId, ss);\n};\n\n/**\n * @method AutoForm.getFieldValue\n * @public\n * @param {String} formId The `id` attribute of the `autoForm` you want current values for.\n * @param {String} fieldName The name of the field for which you want the current value.\n * @return {Any}\n *\n * Returns the value of the field (the value that would be used if the form were submitted right now).\n * This is a reactive method that will rerun whenever the current value of the requested field changes.\n */\nAutoForm.getFieldValue = function autoFormGetFieldValue(formId, fieldName) {\n  formValues[formId] = formValues[formId] || {};\n  formValues[formId][fieldName] = formValues[formId][fieldName] || {_deps: new Deps.Dependency};\n  formValues[formId][fieldName]._deps.depend();\n  return formValues[formId][fieldName]._val;\n};\n\n/**\n * @method AutoForm.inputValueHandlers\n * @public\n * @param {Object} handlers An object defining one or more selectors with corresponding handler function.\n * @return {undefined}\n *\n * Use this method to add custom input value handlers, which will be checked before\n * the built-in handlers.\n */\nAutoForm.inputValueHandlers = function afInputValueHandlers(handlers) {\n  _.extend(customInputValueHandlers, handlers);\n};\n\n/**\n * @method AutoForm.validateField\n * @public\n * @param {String} formId The `id` attribute of the `autoForm` you want to validate.\n * @param {String} fieldName The name of the field within the `autoForm` you want to validate.\n * @param {Boolean} [skipEmpty=false] Set to `true` to skip validation if the field has no value. Useful for preventing `required` errors in form fields that the user has not yet filled out.\n * @return {Boolean} Is it valid?\n *\n * In addition to returning a boolean that indicates whether the field is currently valid,\n * this method causes the reactive validation messages to appear.\n */\nAutoForm.validateField = function autoFormValidateField(formId, fieldName, skipEmpty) {\n  var template = templatesById[formId];\n  if (!template || template._notInDOM) {\n    throw new Error(\"validateField: There is currently no autoForm template rendered for the form with id \" + formId);\n  }\n\n  return _validateField(fieldName, template, skipEmpty, false);\n};\n\n/**\n * @method AutoForm.validateForm\n * @public\n * @param {String} formId The `id` attribute of the `autoForm` you want to validate.\n * @return {Boolean} Is it valid?\n *\n * In addition to returning a boolean that indicates whether the form is currently valid,\n * this method causes the reactive validation messages to appear.\n */\nAutoForm.validateForm = function autoFormValidateForm(formId) {\n  var template = templatesById[formId];\n  if (!template || template._notInDOM) {\n    throw new Error(\"validateForm: There is currently no autoForm template rendered for the form with id \" + formId);\n  }\n\n  var data = formData[formId];\n  // ss will be the schema for the `schema` attribute if present,\n  // else the schema for the collection\n  var ss = data.ss;\n\n  // Gather all form values\n  var formDocs = getFormValues(template, formId, ss);\n\n  var isValid = _validateForm(formId, data, formDocs);\n\n  if (isValid === false) {\n    selectFirstInvalidField(formId, ss, template);\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/**\n * @method AutoForm.getValidationContext\n * @public\n * @param {String} formId The `id` attribute of the `autoForm` for which you want the validation context\n * @return {SimpleSchemaValidationContext} The SimpleSchema validation context object.\n *\n * Use this method to get the validation context, which can be used to check\n * the current invalid fields, manually invalidate fields, etc.\n */\nAutoForm.getValidationContext = function autoFormGetValidationContext(formId) {\n  var data = formData[formId];\n  // ss will be the schema for the `schema` attribute if present,\n  // else the schema for the collection\n  var ss = data.ss;\n  return ss.namedContext(formId);\n};\n\n/**\n * @method AutoForm.find\n * @public\n * @return {Object} The data context for the closest autoform.\n *\n * Call this method from a UI helper to get the data context for the closest autoform. Always returns the context or throws an error.\n */\nAutoForm.find = function autoFormFind(type) {\n  var n = 0, af;\n  do {\n    af = UI._parentData(n++);\n  } while (af && !af._af);\n  if (!af || !af._af) {\n    throw new Error((type || \"AutoForm.find\") + \" must be used within an autoForm block\");\n  }\n  return af._af;\n};\n\n/**\n * @method AutoForm.debug\n * @public\n *\n * Call this method in client code while developing to turn on extra logging.\n */\nAutoForm.debug = function autoFormDebug() {\n  SimpleSchema.debug = true;\n  AutoForm._debug = true;\n  AutoForm.addHooks(null, {\n    onError: function (operation, error, template) {\n      console.log(\"Error in \" + this.formId, operation, error);\n    }\n  });\n};\n\n/**\n * @property AutoForm.arrayTracker\n * @public\n * @param {Object} atts\n * @param {Object} defs\n * @param {Boolean} expectsArray\n *\n * @return {ArrayTracker}\n */\nAutoForm.arrayTracker = arrayTracker;\n\n/**\n * @method AutoForm.getInputType\n * @param {Object} atts The attributes provided to afFieldInput.\n * @public\n * @return {String} The input type. Most are the same as the `type` attributes for HTML input elements, but some are special strings that autoform interprets.\n *\n * Call this method from a UI helper to get the type string for the input control.\n */\nAutoForm.getInputType = getInputType;\n\n/**\n * @method AutoForm.getSchemaForField\n * @public\n * @param {String} name The field name attribute / schema key.\n * @param {Object} [autoform] The autoform context. Optionally pass this if you've already retrieved it using AutoForm.find as a performance enhancement.\n * @return {Object} \n *\n * Call this method from a UI helper to get the field definitions based on the schema used by the closest containing autoForm.\n * Always throws an error or returns the schema object.\n */\nAutoForm.getSchemaForField = function autoFormGetSchemaForField(name, autoform) {\n  var ss;\n  if (autoform) {\n    ss = autoform.ss;\n  }\n  if (!ss) {\n    ss = AutoForm.find().ss;\n  }\n  return Utility.getDefs(ss, name);\n};\n\n/**\n * @method AutoForm.expectsArray\n * @public\n * @param {Object} atts The attributes provided to afFieldInput.\n * @return {Boolean} \n *\n * Call this method from a UI helper to determine whether the user is expecting the input control to produce an array value.\n */\nAutoForm.expectsArray = expectsArray;"]}