)]}'
{"version":3,"file":"/packages/mizzao:timesync.js","sources":["mizzao:timesync/timesync-client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,6B;AACA,wD;;AAEA,c;;AAEA,wC;AACA,iB;AACA,oB;AACA,2B;AACA,mC;AACA,kC;;AAEA,oE;AACA,kE;AACA,2B;AACA,kB;AACA,K;AACA,+B;AACA,iB;AACA,G;AACA,E;;AAEA,oB;AACA,iB;;AAEA,E;AACA,6B;AACA,oD;;AAEA,mE;AACA,6C;AACA,G;AACA,+B;AACA,S;AACA,kB;AACA,kD;AACA,yC;AACA,c;AACA,gE;AACA,2D;AACA,oC;AACA,iD;AACA,U;AACA,8E;AACA,a;AACA,K;;AAEA,8B;;AAEA,wC;AACA,mE;AACA,oE;AACA,sC;AACA,K;AACA,E;;AAEA,+D;AACA,4C;AACA,mE;AACA,+C;AACA,uE;AACA,qD;;AAEA,qE;AACA,2D;AACA,E;;AAEA,uE;AACA,oC;AACA,mC;AACA,8B;AACA,E;;AAEA,qC;AACA,mC;AACA,qC;AACA,E;;AAEA,gC;AACA,mC;AACA,4C;AACA,E;;AAEA,4B;;AAEA,8B;AACA,wE;AACA,iB;AACA,8D;AACA,E;;AAEA,0C;AACA,oG;AACA,E;;AAEA,4D;AACA,0D;AACA,yB;;AAEA,yB;AACA,4C;AACA,sD;AACA,2B;AACA,G;;AAEA,uC;AACA,sD;AACA,0B;;AAEA,2E;AACA,4E;AACA,gF;AACA,uE;AACA,8B;;AAEA,gC;;AAEA,+B;AACA,qC;;AAEA,+B;AACA,8E;AACA,+C;AACA,qC;AACA,G;AACA,Q;AACA,qE;AACA,qC;AACA,qC;AACA,sC;AACA,sB;AACA,G;;AAEA,qC;AACA,mB","sourcesContent":["//IE8 doesn't have Date.now()\nDate.now = Date.now || function() { return +new Date; };\n\nTimeSync = {};\n\n// Internal values, exported for testing\nSyncInternals = {\n  offset: undefined,\n  roundTripTime: undefined,\n  offsetDep: new Deps.Dependency(),\n  timeTick: new Deps.Dependency(),\n\n  timeCheck: function (lastTime, currentTime, interval, tolerance) {\n    if (Math.abs(currentTime - lastTime - interval) < tolerance) {\n      // Everything is A-OK\n      return true;\n    }\n    // We're no longer in sync.\n    return false;\n  }\n};\n\nvar maxAttempts = 5;\nvar attempts = 0;\n\n/*\n  This is an approximation of\n  http://en.wikipedia.org/wiki/Network_Time_Protocol\n\n  If this turns out to be more accurate under the connect handlers,\n  we should try taking multiple measurements.\n */\nvar updateOffset = function() {\n  var t0;\n  t0 = Date.now();\n  HTTP.get(\"/_timesync\", function(err, response) {\n    var t3 = Date.now(); // Grab this now\n    if (err) {\n      //  We'll still use our last computed offset if is defined\n      Meteor._debug(\"Error syncing to server time: \", err);\n      if (++attempts <= maxAttempts)\n        Meteor.setTimeout(TimeSync.resync, 1000);\n      else\n        Meteor._debug(\"Max number of time sync attempts reached. Giving up.\");\n      return;\n    }\n\n    attempts = 0; // It worked\n\n    var ts = parseInt(response.content);\n    SyncInternals.offset = Math.round(((ts - t0) + (ts - t3)) / 2);\n    SyncInternals.roundTripTime = t3 - t0; // - (ts - ts) which is 0\n    SyncInternals.offsetDep.changed();\n  });\n};\n\n// Reactive variable for server time that updates every second.\nTimeSync.serverTime = function(clientTime) {\n  // If we don't know the offset, we can't provide the server time.\n  if ( !TimeSync.isSynced() ) return undefined;\n  // If a client time is provided, we don't need to depend on the tick.\n  if ( !clientTime ) SyncInternals.timeTick.depend();\n\n  // SyncInternals.offsetDep.depend(); implicit as we call isSynced()\n  return (clientTime || Date.now()) + SyncInternals.offset;\n};\n\n// Reactive variable for the difference between server and client time.\nTimeSync.serverOffset = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.offset;\n};\n\nTimeSync.roundTripTime = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.roundTripTime;\n};\n\nTimeSync.isSynced = function() {\n  SyncInternals.offsetDep.depend();\n  return SyncInternals.offset !== undefined;\n};\n\nvar resyncIntervalId = null;\n\nTimeSync.resync = function() {\n  if (resyncIntervalId !== null) Meteor.clearInterval(resyncIntervalId);\n  updateOffset();\n  resyncIntervalId = Meteor.setInterval(updateOffset, 600000);\n};\n\nTimeSync.watchClockChanges = function () {\n  Meteor._debug(\"TimeSync.watchClockChanges() is deprecated; clock watching is now on by default.\");\n};\n\n// Run this as soon as we load, even before Meteor.startup()\n// Run again whenever we reconnect after losing connection\nvar wasConnected = false;\n\nDeps.autorun(function() {\n  var connected = Meteor.status().connected;\n  if ( connected && !wasConnected ) TimeSync.resync();\n  wasConnected = connected;\n});\n\n// resync on major client clock changes\n// based on http://stackoverflow.com/a/3367542/1656818\nvar updateInterval = 1000;\n\n// Resync if unexpected change by more than a few seconds. This needs to be\n// somewhat lenient, or a CPU-intensive operation can trigger a re-sync even\n// when the offset is still accurate. In any case, we're not going to be able to\n// catch very small system-initiated NTP adjustments with this, anyway.\nvar tickCheckTolerance = 5000;\n\nvar lastClientTime = Date.now();\n\nMeteor.setInterval(function() {\n  var currentClientTime = Date.now();\n\n  if ( SyncInternals.timeCheck(\n    lastClientTime, currentClientTime, updateInterval, tickCheckTolerance) ) {\n    // No problem here, just keep ticking along\n    SyncInternals.timeTick.changed();\n  }\n  else {\n    Meteor._debug(\"Clock discrepancy detected. Attempting re-sync.\");\n    // Refuse to compute server time.\n    SyncInternals.offset = undefined;\n    SyncInternals.offsetDep.changed();\n    TimeSync.resync();\n  }\n\n  lastClientTime = currentClientTime;\n}, updateInterval);\n\n"]}